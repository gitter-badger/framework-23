{
    "docs": [
        {
            "location": "/", 
            "text": "About\n\n\nThis is a minimalistic core framework that complies with, supports and uses various \nPSRs:\n\n\n\n\nPSR-2 (Coding Standard)\n\n\nPSR-4 (Autoloading)\n\n\nPSR-7 (HTTP Message)\n\n\nPSR-11 (Container Interface)\n\n\nPSR-15 (HTTP Middleware)\n\n\nPSR-16 (Simple Caching) - \ncontainer wrapper only\n\n\n\n\nWhile it can be used to power a full-blown application framework as of now\nit is mainly oriented towards the core tools needed for building an API.\nRegardless of the fact that it does not come with any transformers/serializers/etc.\nfor doing so there is a complimentary package \nonion/rest\n which provides the ability\nto build APIs that return multiple RESTful responses. It is built only with depending\non \nzendframework/zend-diactoros\n (PSR-7 implementation) so there are no wrappers\naround any external frameworks/components/bundles/etc. so the developer(s) have absolute\ncontrol over what they want to use.\n\n\nThe components included are: DI Container, Middleware Dispatcher, Router and Hydrator traits.\nnothing more, nothing less. There are complementary packages, that are aimed to add\nsome additional features which are more nice-to-have, but not necessarily needed or always \nneeded by everyone, so they will be implemented as separate optional packages and some could\nbe included in the if they prove to be useful for a majority of users and stable enough.\n\n\nNOTICE\n\nThere is no and there will not be an ORM, Template Engine or any-high-level-feature. There are\npleanty of those already available, there is no need to reinvent the wheel.\n\n\n\n\nORM:\n\n\nDoctrine (1 and 2)\n\n\nEloquent\n\n\nPropel\n\n\n\n\n\n\nTemplate Engine:\n\n\nSmarty\n\n\nTwig\n\n\nBlade\n\n\nPlates\n\n\n\n\n\n\n\n\nOne of the main goals for this project was to have a minimal core, without dependencies, \ncompliant with PSRs and allow every oen using it, use what they are familiar with in terms\nof additional packages without having to create wrappers/adapters framework.\n\n\nRequirements\n\n\n\n\nPHP 7.0+\n\n\nphp.ini (Optional but recommended while development)\n\n\nzend.assertions=1\n\n\nassert.exceptions=1\n\n\n\n\n\n\n\n\nThe php.ini configuration is suggested only while development, so that some errors, which \ncould happen only while developing (misspelled array key, invalid configuration, etc.) are\nnot checked all the time while running on production environment - squeezing as much \nperformance as possible.\n\n\nFor a quick start you can clone \nonion/bootstrap\n and \nsee how the basic setup looks like and play around to test the features available.\n\n\nConfiguration\n\n\nThe approach taken for setting up the framework is more configuration over convention\nbecause everyone has different code-style and different tastes, there is no point in \nenforcing a specific way to code something so that it works, without providing any \nother way. So there are some configurations for some components and they are explained\nin their respectful sections of this documentation.", 
            "title": "Intro"
        }, 
        {
            "location": "/#about", 
            "text": "This is a minimalistic core framework that complies with, supports and uses various \nPSRs:   PSR-2 (Coding Standard)  PSR-4 (Autoloading)  PSR-7 (HTTP Message)  PSR-11 (Container Interface)  PSR-15 (HTTP Middleware)  PSR-16 (Simple Caching) -  container wrapper only   While it can be used to power a full-blown application framework as of now\nit is mainly oriented towards the core tools needed for building an API.\nRegardless of the fact that it does not come with any transformers/serializers/etc.\nfor doing so there is a complimentary package  onion/rest  which provides the ability\nto build APIs that return multiple RESTful responses. It is built only with depending\non  zendframework/zend-diactoros  (PSR-7 implementation) so there are no wrappers\naround any external frameworks/components/bundles/etc. so the developer(s) have absolute\ncontrol over what they want to use.  The components included are: DI Container, Middleware Dispatcher, Router and Hydrator traits.\nnothing more, nothing less. There are complementary packages, that are aimed to add\nsome additional features which are more nice-to-have, but not necessarily needed or always \nneeded by everyone, so they will be implemented as separate optional packages and some could\nbe included in the if they prove to be useful for a majority of users and stable enough.  NOTICE \nThere is no and there will not be an ORM, Template Engine or any-high-level-feature. There are\npleanty of those already available, there is no need to reinvent the wheel.   ORM:  Doctrine (1 and 2)  Eloquent  Propel    Template Engine:  Smarty  Twig  Blade  Plates     One of the main goals for this project was to have a minimal core, without dependencies, \ncompliant with PSRs and allow every oen using it, use what they are familiar with in terms\nof additional packages without having to create wrappers/adapters framework.", 
            "title": "About"
        }, 
        {
            "location": "/#requirements", 
            "text": "PHP 7.0+  php.ini (Optional but recommended while development)  zend.assertions=1  assert.exceptions=1     The php.ini configuration is suggested only while development, so that some errors, which \ncould happen only while developing (misspelled array key, invalid configuration, etc.) are\nnot checked all the time while running on production environment - squeezing as much \nperformance as possible.  For a quick start you can clone  onion/bootstrap  and \nsee how the basic setup looks like and play around to test the features available.", 
            "title": "Requirements"
        }, 
        {
            "location": "/#configuration", 
            "text": "The approach taken for setting up the framework is more configuration over convention\nbecause everyone has different code-style and different tastes, there is no point in \nenforcing a specific way to code something so that it works, without providing any \nother way. So there are some configurations for some components and they are explained\nin their respectful sections of this documentation.", 
            "title": "Configuration"
        }, 
        {
            "location": "/setup/", 
            "text": "Getting started\n\n\nIn this section we'll get through a simple hello world app to help you\nget a grip around the concepts of the framework as well as how to\nset it up and work on it.\n\n\n1st thing is the index file, it is the entry point for the application.\nThe application consists of middleware, which if you are not familiar\nwith you should think of as onion's layers (now you get where the name\ncomes from). See:\n\n\n\n\n\n\nPSR-15 Specification\n\n\n\n\n\n\nWhy Care About PHP Middleware?\n by \nPhil Phil Sturgeon\n\n\n\n\n\n\nChosing single pass ensures no funny business will be going inside the\nmiddleware you use, and you can be sure that the response you return\nwill be consistently handled, and you will not have to keep track of\nthe double-pass response object, that may or may not have some specific\nheaders set by any of the middleware called before your \"controller\".\n\n\nInstallation\n\n\nSo with that being said, lets jump right in with the installation\nand setup of the \"hello world\" project:\n\n\n\n\ncomposer require onion/framework:1.0.0-beta\n\n\nCreate the public directory one that will be exposed by the web\nserver, referred to as \npublic\n in this example\n\n\nIn it, create a file named \nindex.php\n and inside of it paste the\ncode below.\n\n\nTo test it after you copied and pasted the code run the following:\n \nphp -S localhost:12345 -t public/\n inside the projects directory,\n that will start the PHP built-in server and will make the application\n  code accessible on: \nlocalhost:12345\n\n\n\n\n    \n?php\n    declare(strict_types=1);\n    require_once __DIR__ . '/../vendor/autoload.php';\n    use Onion\\Framework;\n\n    $container = new Framework\\Dependency\\Container([]);\n\n    $app = $container-\nget(Framework\\Application\\Application::class);\n    $app-\nrun(\n        $container-\nget(\\Psr\\Http\\Message\\ServerRequestInterface::class)\n    );\n\n\n\n\nThis is the minimal required code in order to set up the application\nentry point.\n\n\n\n\nDependencies\n\n\nNow if you open the link with your browser, you will see there is an\nexception being thrown, similar to (if no the same as):\n\n\n\n\nUncaught Onion\\Framework\\Dependency\\Exception\\ContainerErrorException: Unable to find match for type: \"Interop\\Http\\Middleware\\DelegateInterface\". Consider using a factory\n...\n\n\n\n\nWhat this means is that the container is unable to resolve the\ndependency of \nDelegateInterface\n, this sucks big time, now before you\nstart digging in the code, hold on for a sec and lets see what happens\nin our \nindex.php\n file.\n\n\n\n\n\n\nL2-L4\n - We declare that we will use strict types, require the\ncomposer autoloader and localize the namespace (a bit shorter to write)\n\n\n\n\n\n\nL6\n - We initialize the DI container without any registered\ndependencies (pay attention to the empty array passed as argument),\nwhich will make the container to use only reflection in order to look-up\ndependencies recursively as deep as it can go, but since we are doing\nthings the DbC(Design by Contract) way, it has no way of knowing from\nwhere to get an implementation of the interface (contract).\n\n\n\n\n\n\nL8\n - We attempt to retrieve the \nApplication\n class from the\ncontainer (This is where the exception gets thrown)\n\n\n\n\n\n\nL9-L11\n - We attempt to run the application by passing it the\ncurrent request object, again retrieved from the container\n\n\n\n\n\n\nIn order to learn more about the \nDelegateInterface\n make sure you read\nthe PSR-15 spec. Now in the implementation the Application object\nreceives 2 arguments in it's constructor:\n\n\n\n\nDelegateInterface\n - Is a delegate which is to delegate all of\n  the global middleware.\n\n\nEmitterInterface\n - Is responsible for emitting our response\n  \"on the way out\"\u2122..\n\n\n\n\nThe reason behind binding everything to interfaces (whenever possible)\ncomes from the DbC (Design by Contract) approach, which makes the\napplication as [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)\nas possible. I can't stress enough on how important this is and you\nshould adopt and apply that mindset when possible.\n\n\nNow let's update our index to include the \nDelegateInterface\n and\n\nEmitterInterface\n in a dependency mapping so that our container knows\nwhat to return when we need any of those dependencies.\n\n\n// Replace the empty array argument for container with the following\n\n[\n    'invokables' =\n [\n        Zend\\Diactoros\\Response\\EmitterInterface::class =\n\n            Zend\\Diactoros\\Response\\SapiEmitter::class\n    ],\n    'factories' =\n [\n        Interop\\Http\\Middleware\\DelegateInterface::class =\n\n            Framework\\Application\\Factory\\GlobalDelegateFactory::class\n    ]\n]\n\n\n\n\n\n\nMiddleware\n\n\nNow if you run the application you will notice that there is an entierly\ndifferent error, about missing \nmiddleware\n key.\n\n\n\n\nUncaught Onion\\Framework\\Dependency\\Exception\\UnknownDependency: Unable to resolve \"middleware\"\n\n\n\n\nThis is because the \nGlobalDelegateFactory\n expects to see \nmiddleware\n\nkey inside our container and use it in order to build the necessary call\nstack. Lets add it, but leave it empty. Add \n'middleware' =\n []\n after\nthe factory definition in the top level array.\n\n\n\n\nReturn value of Onion\\Framework\\Application\\Factory\\GlobalDelegateFactory::build() must be an instance of Interop\\Http\\Middleware\\DelegateInterface, null returned\n\n\n\n\nIs pretty self explanatory, but why you ask? Well, the factory needs at\nleast one entry inside the \nmiddleware\n in order to build a\n\nDelegateInterface\n with it, just keep in mind it MUST be an instance of\neither \nInterop\\Http\\Middleware\\MiddlewareInterface\n or\n\nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n and since we are\nbuilding a server application (not a HTTP client) we will pass in an\nargument that is vital to any HTTP application - a router.\nBut to avoid the error steps above, I will directly tell you that you\nhave to define those in order to get it going. Update the array to look\nlike the following:\n\n\n[\n    'invokables' =\n [\n        Zend\\Diactoros\\Response\\EmitterInterface::class =\n\n            Zend\\Diactoros\\Response\\SapiEmitter::class,\n        Framework\\Router\\Interfaces\\ParserInterface::class =\n\n            Framework\\Router\\Parsers\\Flat::class,\n        Framework\\Router\\Interfaces\\MatcherInterface::class =\n\n            Framework\\Router\\Matchers\\Strict::class\n    ],\n    'factories' =\n [\n        Interop\\Http\\Middleware\\DelegateInterface::class =\n\n            Framework\\Application\\Factory\\GlobalDelegateFactory::class,\n        Framework\\Router\\Interfaces\\RouterInterface::class =\n\n            Framework\\Router\\Factory\\RouterFactory::class,\n        Psr\\Http\\Message\\ServerRequestInterface::class =\n\n            Framework\\Http\\Factory\\ServerRequestFactory::class\n    ],\n    'middleware' =\n [\n        Framework\\Router\\Interfaces\\RouterInterface::class\n    ],\n    'routes' =\n []\n]\n\n\n\n\n\n\nRouting\n\n\nSince our router implements the \nServerMiddlewareInterface\n we can pass\nit without any other boilerplate to the middleware section and the\nother 2 dependencies inside the invokables section are for making it\nwork.\n\n\n\n\n\n\nFramework\\Router\\Interfaces\\ParserInterface\n is responsible for\n translating the route definitions to mathcer understandable string\n\n\n\n\n\n\nFramework\\Router\\Interfaces\\MatcherInterface\n is the one performing\n the matching in order to see if the current request URI matches a route\n\n\n\n\n\n\nIn this case we are using the flat matcher, which returns the pattern as\nis and the strict matcher that performs \na === b\n kind of checks.\n\n\n\n\nNow if we refresh the page we will se that there will be an exception:\n\n\n\n\nUncaught Onion\\Framework\\Router\\Exceptions\\NotFoundException: No route available to handle \"/\"\n\n\n\n\nNow lets create our first controller, add autoloading for the\n\nApplication\n namespace to composer and inside\n\nsrc/Controllers/DummyController.php\n paste the following:\n\n\n?php\ndeclare(strict_types=1);\n\nnamespace App\\Controllers;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\nclass DummyController implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate = null)\n    {\n        return new TextResponse('Hello, World!');\n    }\n}\n\n\n\n\nNow that you are done, lets add the controller to the \nroutes\n:\n\n\n// .. other definitions\n'routes' =\n [\n  [\n    'pattern' =\n '/',\n    'middleware' =\n [\n        App\\Controllers\\DummyMiddleware::class\n    ]\n  ]\n]\n\n\n\n\n\n\nFQCN\n - \nFully Qualified Class Name\n\n\n\n\nNow if all went well you should not see any further errors when you\nrefresh the page, but rather the text 'Hello, World!' should be\ndisplayed and the response should be sent with\n\nContent-Type: text/plain\n header.\n\n\nThis is the minimal required setup needed in order to setup an\napplication using onion framework and from here you can conquer the\nworld! Check other sections from the documentation to get more in-depth\nunderstanding/knowledge of the routing capabilities, the concept of\nmodules and everything else.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/setup/#getting-started", 
            "text": "In this section we'll get through a simple hello world app to help you\nget a grip around the concepts of the framework as well as how to\nset it up and work on it.  1st thing is the index file, it is the entry point for the application.\nThe application consists of middleware, which if you are not familiar\nwith you should think of as onion's layers (now you get where the name\ncomes from). See:    PSR-15 Specification    Why Care About PHP Middleware?  by  Phil Phil Sturgeon    Chosing single pass ensures no funny business will be going inside the\nmiddleware you use, and you can be sure that the response you return\nwill be consistently handled, and you will not have to keep track of\nthe double-pass response object, that may or may not have some specific\nheaders set by any of the middleware called before your \"controller\".", 
            "title": "Getting started"
        }, 
        {
            "location": "/setup/#installation", 
            "text": "So with that being said, lets jump right in with the installation\nand setup of the \"hello world\" project:   composer require onion/framework:1.0.0-beta  Create the public directory one that will be exposed by the web\nserver, referred to as  public  in this example  In it, create a file named  index.php  and inside of it paste the\ncode below.  To test it after you copied and pasted the code run the following:\n  php -S localhost:12345 -t public/  inside the projects directory,\n that will start the PHP built-in server and will make the application\n  code accessible on:  localhost:12345        ?php\n    declare(strict_types=1);\n    require_once __DIR__ . '/../vendor/autoload.php';\n    use Onion\\Framework;\n\n    $container = new Framework\\Dependency\\Container([]);\n\n    $app = $container- get(Framework\\Application\\Application::class);\n    $app- run(\n        $container- get(\\Psr\\Http\\Message\\ServerRequestInterface::class)\n    );  This is the minimal required code in order to set up the application\nentry point.", 
            "title": "Installation"
        }, 
        {
            "location": "/setup/#dependencies", 
            "text": "Now if you open the link with your browser, you will see there is an\nexception being thrown, similar to (if no the same as):   Uncaught Onion\\Framework\\Dependency\\Exception\\ContainerErrorException: Unable to find match for type: \"Interop\\Http\\Middleware\\DelegateInterface\". Consider using a factory\n...   What this means is that the container is unable to resolve the\ndependency of  DelegateInterface , this sucks big time, now before you\nstart digging in the code, hold on for a sec and lets see what happens\nin our  index.php  file.    L2-L4  - We declare that we will use strict types, require the\ncomposer autoloader and localize the namespace (a bit shorter to write)    L6  - We initialize the DI container without any registered\ndependencies (pay attention to the empty array passed as argument),\nwhich will make the container to use only reflection in order to look-up\ndependencies recursively as deep as it can go, but since we are doing\nthings the DbC(Design by Contract) way, it has no way of knowing from\nwhere to get an implementation of the interface (contract).    L8  - We attempt to retrieve the  Application  class from the\ncontainer (This is where the exception gets thrown)    L9-L11  - We attempt to run the application by passing it the\ncurrent request object, again retrieved from the container    In order to learn more about the  DelegateInterface  make sure you read\nthe PSR-15 spec. Now in the implementation the Application object\nreceives 2 arguments in it's constructor:   DelegateInterface  - Is a delegate which is to delegate all of\n  the global middleware.  EmitterInterface  - Is responsible for emitting our response\n  \"on the way out\"\u2122..   The reason behind binding everything to interfaces (whenever possible)\ncomes from the DbC (Design by Contract) approach, which makes the\napplication as [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)\nas possible. I can't stress enough on how important this is and you\nshould adopt and apply that mindset when possible.  Now let's update our index to include the  DelegateInterface  and EmitterInterface  in a dependency mapping so that our container knows\nwhat to return when we need any of those dependencies.  // Replace the empty array argument for container with the following\n\n[\n    'invokables' =  [\n        Zend\\Diactoros\\Response\\EmitterInterface::class = \n            Zend\\Diactoros\\Response\\SapiEmitter::class\n    ],\n    'factories' =  [\n        Interop\\Http\\Middleware\\DelegateInterface::class = \n            Framework\\Application\\Factory\\GlobalDelegateFactory::class\n    ]\n]", 
            "title": "Dependencies"
        }, 
        {
            "location": "/setup/#middleware", 
            "text": "Now if you run the application you will notice that there is an entierly\ndifferent error, about missing  middleware  key.   Uncaught Onion\\Framework\\Dependency\\Exception\\UnknownDependency: Unable to resolve \"middleware\"   This is because the  GlobalDelegateFactory  expects to see  middleware \nkey inside our container and use it in order to build the necessary call\nstack. Lets add it, but leave it empty. Add  'middleware' =  []  after\nthe factory definition in the top level array.   Return value of Onion\\Framework\\Application\\Factory\\GlobalDelegateFactory::build() must be an instance of Interop\\Http\\Middleware\\DelegateInterface, null returned   Is pretty self explanatory, but why you ask? Well, the factory needs at\nleast one entry inside the  middleware  in order to build a DelegateInterface  with it, just keep in mind it MUST be an instance of\neither  Interop\\Http\\Middleware\\MiddlewareInterface  or Interop\\Http\\Middleware\\ServerMiddlewareInterface  and since we are\nbuilding a server application (not a HTTP client) we will pass in an\nargument that is vital to any HTTP application - a router.\nBut to avoid the error steps above, I will directly tell you that you\nhave to define those in order to get it going. Update the array to look\nlike the following:  [\n    'invokables' =  [\n        Zend\\Diactoros\\Response\\EmitterInterface::class = \n            Zend\\Diactoros\\Response\\SapiEmitter::class,\n        Framework\\Router\\Interfaces\\ParserInterface::class = \n            Framework\\Router\\Parsers\\Flat::class,\n        Framework\\Router\\Interfaces\\MatcherInterface::class = \n            Framework\\Router\\Matchers\\Strict::class\n    ],\n    'factories' =  [\n        Interop\\Http\\Middleware\\DelegateInterface::class = \n            Framework\\Application\\Factory\\GlobalDelegateFactory::class,\n        Framework\\Router\\Interfaces\\RouterInterface::class = \n            Framework\\Router\\Factory\\RouterFactory::class,\n        Psr\\Http\\Message\\ServerRequestInterface::class = \n            Framework\\Http\\Factory\\ServerRequestFactory::class\n    ],\n    'middleware' =  [\n        Framework\\Router\\Interfaces\\RouterInterface::class\n    ],\n    'routes' =  []\n]", 
            "title": "Middleware"
        }, 
        {
            "location": "/setup/#routing", 
            "text": "Since our router implements the  ServerMiddlewareInterface  we can pass\nit without any other boilerplate to the middleware section and the\nother 2 dependencies inside the invokables section are for making it\nwork.    Framework\\Router\\Interfaces\\ParserInterface  is responsible for\n translating the route definitions to mathcer understandable string    Framework\\Router\\Interfaces\\MatcherInterface  is the one performing\n the matching in order to see if the current request URI matches a route    In this case we are using the flat matcher, which returns the pattern as\nis and the strict matcher that performs  a === b  kind of checks.   Now if we refresh the page we will se that there will be an exception:   Uncaught Onion\\Framework\\Router\\Exceptions\\NotFoundException: No route available to handle \"/\"   Now lets create our first controller, add autoloading for the Application  namespace to composer and inside src/Controllers/DummyController.php  paste the following:  ?php\ndeclare(strict_types=1);\n\nnamespace App\\Controllers;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\nclass DummyController implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate = null)\n    {\n        return new TextResponse('Hello, World!');\n    }\n}  Now that you are done, lets add the controller to the  routes :  // .. other definitions\n'routes' =  [\n  [\n    'pattern' =  '/',\n    'middleware' =  [\n        App\\Controllers\\DummyMiddleware::class\n    ]\n  ]\n]   FQCN  -  Fully Qualified Class Name   Now if all went well you should not see any further errors when you\nrefresh the page, but rather the text 'Hello, World!' should be\ndisplayed and the response should be sent with Content-Type: text/plain  header.  This is the minimal required setup needed in order to setup an\napplication using onion framework and from here you can conquer the\nworld! Check other sections from the documentation to get more in-depth\nunderstanding/knowledge of the routing capabilities, the concept of\nmodules and everything else.", 
            "title": "Routing"
        }, 
        {
            "location": "/dependency/", 
            "text": "The app comes with a very capable DI container, that provides the essential\nfunctionality to get an app running with as little issues as possible. It is\npretty similar to the one provided from ZF, but with some features omitted. \nThe container's dependencies are passed as an array in it's constructor and \nhave 3 special keys: \ninvokables\n, \nfactories\n and \nshared\n\n\nEverything outside of these 3 keys is treated just as a value and can be retrieved by calling \n\nContainer::get('someKey)\n and that will return the value of 'someKey' as-is, without performing\nany operations on it. Also if you need to access a specific key which is located in a nested \narray you can use a dot notation, which the container will interpret as indication for a level\nof the array. Say for example, you have an array:\n\n\n[\n    // ...\n    'doctrine' =\n [\n        'connection' =\n [\n            'dbname' =\n 'foo',\n            // ...\n        ]\n    ]\n    // ...\n]\n\n\n\n\nIn order to access \n'dbname\n, you might have to do at least 2 ifs (to ensure the key is there)\nand definitely will have to make something like: \nContainer::get('doctrine')['connection']['dbname']\n,\nnot the prettiest... This is where this could come in to play, instead of doing that you can just du\n\nContainer::get('doctrine.connection.dbname'); // Returns 'foo'\n and you are all set, and it looks \nclearer too + on thje bonus side if you are writing a distributable module, you can be sure that the\ncontainer will throw the appropriate error if any key is not defined and notify the user, no more \npiles of \nif\ns in your factories :)", 
            "title": "Introduction"
        }, 
        {
            "location": "/dependency/invokables/", 
            "text": "invokables\n are mappings from type to implementation, this is mainly intended\n for cases where a class binds to an interface and when the container needs to inject\n a blank instance of a given class. This will not perform any operations on the instance\n so it is expected those to be instances without a constructor or with a constructor that\n does not need any arguments. Consider it as a mapping between \ninterface =\n implementation\n\n\nA good practise is to use \n\\Acme\\App\\SomeClass::class\n instead of \n'someclass'\n as keys so\nit allows for auto-wiring and makes the code more obvious, more readable and decoupled from \nthe configuration.\n\n\nFor example:\n\n\n//...\n    'invokables' =\n [\n         \\Psr\\Http\\Message\\ResponseInterface::class =\n Zend\\Diactoros\\Response::class,\n         \\Zend\\Diactoros\\Response\\EmitterInterface::class =\n \\Zend\\Diactoros\\Response\\SapiEmitter::class,\n    ]\n//...\n\n\n\n\nCreates a mapping that whenever an object requires \nResponseInterface\n the container will return \n\nnew Response()\n and the same goes for the \nEmitterInterface\n, this is useful when you have only\ntype-hint against an interface instead of a specific implementation, this will trigger the container\nto perform a lookup on the dependencies of the defined class in an attempt to return a fully setup\ninstance. And while invokables are available it is not necessary to define each and every class in this mapping,\nbut rather only those which bind to interface, for those that are type-hinted to a concrete \nimplementation the container will attempt to do it's best to resolve it automatically from the available \ntypes and other definitions passed. \n\n\nBut in scenarios where you need a specific configuration that the container cannot resolve\nyou can turn to the next keyword", 
            "title": "Invokables"
        }, 
        {
            "location": "/dependency/factories/", 
            "text": "factories\n are another essential part of the container. These are manually created classes that\nimplement \n\\Onion\\Framework\\Dependency\\Interfaces\\FactoryInterface\n and serve as \"formulas\" how\nto build the dependency.\n\n\n\n\nFor example:\n\n\n// ...\n    'factories' =\n [\n        \\Onion\\Framework\\Router\\Interfaces\\RouterInterface::class =\n\n            \\Onion\\Framework\\Router\\Factory\\RouterFactory::class,\n    ]\n//...\n\n\n\n\nThis tells the container, whenever \nRouterInterface\n is requested, to invoke the \nRouterFactory\n\nwhich returns an instance of the interface. This is the flexibility point of the container (not an\nexclusive feature but still) since it allows you to define manually the way an object instance is\nbuild and also provides an abstraction between the container's resolution and implementation details.\nIf you use setter injection you will have to use factories, as the container does not provide any \nway to auto-wire them. Also setter injected dependencies, could be considered optional and may not\nbe needed for the class, no need to spend time on them.\n\n\n\n\nAnd if an object is often required, but does not need to be instantiated multiple times,\nthere is the \nshared\n key. It allows you to define the a list of factories that should not\nbe triggered on every request, but actually \"share\" the same instance of the first result.\nThis can be useful in scenarios like, constructing database connection, instantiating \nconnection to a remote service, etc. The main intent for this is to be used for heavy\nobjects which might be required on multiple places.", 
            "title": "Factories"
        }, 
        {
            "location": "/dependency/caching/", 
            "text": "When applications are running on production it is safe to assume that DI containers \ncan make relatively heavy use of caching so they can squeeze the maximum \nperformance. This is should not be any different. And to make this possible\nit is not necessary to come up with your own solution. A caching (delegate)container \ncomes bundled inside the framework - \nOnion\\Framework\\Dependency\\CacheAwareContainer\n.\nIn order to utilize it you just have to define a container factory (a class\nimplementing the \nFactoryInterface\n) and pass it as the first argument to the\ncache-aware container, pass an instance of \nPsr\\SimpleCache\\CacheInterface\n\nas the second one and you are ready to go.\n\n\nBy default that container will cache every dependency that it retrieves, but\nif you have a factory that, for example checks for results in the database and\nuses information from there to build the dependency on a per-user basis you \nmight not want to cache that result, here comes the third argument of the \ncontainer - blacklist. It allows you to specify a list of keys that should \nnot be cached and should always be retrieved from the delegated container.", 
            "title": "Caching"
        }, 
        {
            "location": "/routing/", 
            "text": "There is a router included within the framework which provides the\nmost commonly needed features the get an application up and running. The router it comes with 2 separate logical components in order to provide maximum flexibility, namely parsers and matchers.\n\n\nWith those components one can alter some of the logic that the routing performs and thus allow developers to use the router but alter it's internals to fit their needs better.", 
            "title": "Introduction"
        }, 
        {
            "location": "/routing/parsers/", 
            "text": "Parsers are responsible for translating the route's path definition\nto something that the matchers can understand and process. The ones provided by default are:\n\n\n\n\nFlat\n: Extracts the path of the current request and returns it. The main purpose of the flat parser is to ensure only the path of the request is extracted in order to allow static routing (i.e one without any parameters, useful for small static sites).\n\n\nRegex\n: This one is more complex as it adds the ability to have parameters inside the path. It translates a path definition to a parametrized regex should serve most cases for dynamic applications.\n\n\n\n\nThe flat parser does not have any specific semantics, but the regex (as you might have guessed) has. When defining the pattern,\nyou should denote the parameters in square braces \n[]\n, so a pattern for a user endpoint becomes \n/users/[id]\n this will extract the the value of \nid\n and set it as attribute of the Request object when it gets processed by the matcher and router.\n\n\nIf you need to provide constraints to your patterns you can use \n:\n after the parameter name and provide either a regex pattern or one of the \n*\n or \n?\n which map to \n\\w+\n and \n\\w\n respectively.\n\n\nSo \n/users/[id:*]\n will match \n/users/a\n as well as \n/users/alpha\n, but \n/users/[id:?]\n will match only \n/users/a\n.\nBut sometimes one might want to add a more specific pattern, like when the \nid\n can only be a number. This is also possible with the syntax above, just change the pattern to \n/users/[id:\\d+]\n that way it will match only arguments that match the \n\\d+\n regex.\n\n\nAnd there is a special case for regex patterns that provide the catch-all functionality, its syntax is like the following\n\n/users*\n, note that there is no \n:\n nor braces. This is the absolute wildcard so to speak. If you have a pattern \n\n/users/*/[id:\\d+]\n this will match all sorts of paths, like: \n/users/some/non/strict/path/with/id/5", 
            "title": "Parsers"
        }, 
        {
            "location": "/routing/matchers/", 
            "text": "Matchers are relatively simple object, their point is to take the transformed route pattern and check if it matches the current path or not and return any possible parameters to be used from the router.\n\n\nThere is not much to them really...", 
            "title": "Matchers"
        }, 
        {
            "location": "/routing/pipes/", 
            "text": "In middleware world, there is the concept of piping (Zend Stratigility).\nPipes serve as a wildcard wildcard catch-group type of routes and while \nthere is no helper method defined, currently the same functionality is \npossible when using the \nRegex\n route matcher and the catch-all routes.\n\n\nIf you are looking to create a pipe for all requests to \n/users/\n, you can \ndefine your pattern like \n/users/*\n and then pass it to a module that will \nhandle that group. Note that in this scenario, the module is aware of the\nprefix you should keep that in mind. Also there are more complex cases which \nyou can also handle using this kind of pipes. Say for example you have a blog\nsite and all article titles are within the url (SEO-friendly), but you want to \nshow a different page, instead of the default 404, here you can play with the\nwith a pipe and with the catch-all, you just need to define your pipe for \n\n/articles/*\n and then as a last route, define it again, but this time with a\nmiddleware retuning the desired result, instead of showing a plain old 404 page\n(an idea might be to check the possible path and try make suggestions).", 
            "title": "Pipes"
        }, 
        {
            "location": "/modules/", 
            "text": "Introduction\n\n\nModules are not a new concept in the development world, nor they re new\nto the PHP frameworks/applications. The implementation used here is not\ntoo different from what has already been implemented in other frameworks\nbut the intent is clear and is aimed at enforcing the separation of\napplications in logical parts, rather than having module provide\nhelper functionality (although they can also be used in that way, but\nmight fee less intuitive)\n\n\nSetup\n\n\nA module must be as self-contained as possible. It is up to the module\ndeveloper to determine what configuration is comming from where, but\nmandatory (such as internal dependency mapping) should be defined and\nmight even be appropriate to have it hardcoded, but optional things,\nsuch as database connection settings, etc. should be retrieved from the\nmain application container via an acceptable method explained inside\nmodule's \nreadme\n on \ninstallation\n files.\n\n\nA module should have it's logic as self-contained as possible, except\nfor configurations, since that will change from application to\napplication.\n\n\nThe only requirement in order to ensure consistency (as of now it is not\nenforced) is for the module to serve as a factory that MUST return\ninstance of \nApplication\n, since application is a middleware it does not\nintroduce a very specific behaviour, except maybe for having a separate\nmiddleware delegate defined and a separate router for the module itself.\n\n\nInternally the \nModuleDelegateFactory\n is building a router with every\ninstance \nApplication\n assigned it's own prefix inside a \nmodule\n key.\n\n\nConfiguration\n\n\nThe minimal configuration to the container is:\n\n\nreturn [\n    // .. other configuration\n    'middleware' =\n [\n        'modules'\n    ],\n    'modules' =\n [\n        '/path/prefix' =\n MyApp\\API\\Module::class\n    ]\n]\n\n\n\n\nAn example module class:\n\n\nnamespace MyApp\\API;\n\nuse Interop\\Container\\ContainerInterface;\nuse Onion\\Framework\\Application\\Application;\nuse Onion\\Framework\\Application\\Interfaces\\ModuleInterface;\n\nclass Module implements ModuleInterface\n{\n    // Optional, but makes things clearer\n    private function getConfigurations(): array\n    {\n        return [\n            'routes' =\n [\n                [\n                    'pattern' =\n '/api/users',\n                    'middleware' =\n [\n                        UsersApiController::class\n                    ]\n                ]\n            ]\n        ];\n    }\n\n    public function build(ContainerInterface $container): Application\n    {\n        return new Application\n            // Retrieve everything from a contextual container\n            $this-\ngetOwnContainer()-\nget(\\Interop\\Middleware\\DelegateInterface),\n            $container-\nget(EmitterInterface::class)\n        );\n    }\n}\n\n\n\n\nIt is recommended for a module class to fetch the \nEmitterInterface\n\nfrom the main container, instead of defining it's own since it will\navoid issues with custom emitter implementations if applicable. Also\nnote that the route must have the prefix defined by default in order to\navoid this duplication (if that is your thing, but do keep in mind that\nthe intent behind this kind of modules is that a module can and should\nbe able to function as it's own application and not only as a module of\nanother). Once the initial testing has been performed a CLI application\nwill be developed allowing for the generation of module classes from\nexisting applications, which will empower use-cases such as minimal blog\nto be embedded inside another application at a prefix; as well as\ninstall/uninstall steps, but that is TBD as of now so don't rely\ncompletely on that, but do keep in mind that the reasoning behind the\nmodules is here to stay.\n\n\nRecommendations\n\n\nMajority of the following points are intended to serve only as\nguide lines, and developers are free to ignore them, but complying\nwill ensure consistency between module structure and workflow, hence\nimproving experience\n\n\n\n\n\n\nA module is a component of an application or website that provides visitor\n access to specific part of the website, a module should not only provide\n libraries and/or frameworks (for that part please stick with composer, see\n \ncomposer documentation for information on how to use VCS for package distribution\n).\n\n\n\n\n\n\nA module should provide contact information to allow users to report issues\n make/discuss feature requests and/or disclose security vulnerabilities.\n\n\n\n\n\n\nAnother highly recommended thing to do is follow the PHP standards (PSR) to\n ensure compatibility with other libraries/modules/frameworks, that the\n user might be using within their application, out of the box.\n\n\n\n\n\n\nFollowing the HTTP standards is also a good thing to do, since that will\n increase the flexibility of user implementations in a magnitude. Example:\n if you provide \nLast-Modified\n header and check for \nIf-Modified-Since\n\n the application may become more performant, since no data should be\n transfered.\n\n\n\n\n\n\nAs a developer you should try to keep the dependencies for your module\n as minimal as possible so users do not get bloated with dependencies,\n also as a added benefit you lower the risk of your module breaking, because\n of external changes.\n\n\n\n\n\n\nA module, should not provide/enforce specific view components, since it\n may break application/website functionality/appearance, rather a API backend\n should be previded with information/tutorials/examples on how to communicate\n with said backend in a consistent way. *Design your modules for front ends\n built using modern frameworks like, ReactJS and Angular2 or other similar ones.\n\n\n\n\n\n\nA module should be kept as small and self-contained as possible. For example\n if a module is intended to provide blogging functionality it should (where applicable)\n be split in separate compoenets for \nposts\n, \ncomments\n, \nediting\n. That way users\n would have the opportunity to mix and match compoents that are compatible or directly\n write a custom one to fit their needs or bridge gaps between different modules.\n\n\n\n\n\n\nA module may communicate with existing services, but it is recommended to provide\n information with which services/3rd parties information is exchanged and for what\n purposes.\n\n\n\n\n\n\nA module should not intend to modify files inside or outside of itself, when such\n configuration is required it should provide detailed information what, where and why\n should be changed for the user to configure (or optionally a script can be provided,\n but not automatically executed)\n\n\n\n\n\n\nOptionally your module may provide a UI, but it should be implemented in such a way\n that it's styling should be easily changeable since, different people have different\n tastes.", 
            "title": "Modules"
        }, 
        {
            "location": "/modules/#introduction", 
            "text": "Modules are not a new concept in the development world, nor they re new\nto the PHP frameworks/applications. The implementation used here is not\ntoo different from what has already been implemented in other frameworks\nbut the intent is clear and is aimed at enforcing the separation of\napplications in logical parts, rather than having module provide\nhelper functionality (although they can also be used in that way, but\nmight fee less intuitive)", 
            "title": "Introduction"
        }, 
        {
            "location": "/modules/#setup", 
            "text": "A module must be as self-contained as possible. It is up to the module\ndeveloper to determine what configuration is comming from where, but\nmandatory (such as internal dependency mapping) should be defined and\nmight even be appropriate to have it hardcoded, but optional things,\nsuch as database connection settings, etc. should be retrieved from the\nmain application container via an acceptable method explained inside\nmodule's  readme  on  installation  files.  A module should have it's logic as self-contained as possible, except\nfor configurations, since that will change from application to\napplication.  The only requirement in order to ensure consistency (as of now it is not\nenforced) is for the module to serve as a factory that MUST return\ninstance of  Application , since application is a middleware it does not\nintroduce a very specific behaviour, except maybe for having a separate\nmiddleware delegate defined and a separate router for the module itself.  Internally the  ModuleDelegateFactory  is building a router with every\ninstance  Application  assigned it's own prefix inside a  module  key.", 
            "title": "Setup"
        }, 
        {
            "location": "/modules/#configuration", 
            "text": "The minimal configuration to the container is:  return [\n    // .. other configuration\n    'middleware' =  [\n        'modules'\n    ],\n    'modules' =  [\n        '/path/prefix' =  MyApp\\API\\Module::class\n    ]\n]  An example module class:  namespace MyApp\\API;\n\nuse Interop\\Container\\ContainerInterface;\nuse Onion\\Framework\\Application\\Application;\nuse Onion\\Framework\\Application\\Interfaces\\ModuleInterface;\n\nclass Module implements ModuleInterface\n{\n    // Optional, but makes things clearer\n    private function getConfigurations(): array\n    {\n        return [\n            'routes' =  [\n                [\n                    'pattern' =  '/api/users',\n                    'middleware' =  [\n                        UsersApiController::class\n                    ]\n                ]\n            ]\n        ];\n    }\n\n    public function build(ContainerInterface $container): Application\n    {\n        return new Application\n            // Retrieve everything from a contextual container\n            $this- getOwnContainer()- get(\\Interop\\Middleware\\DelegateInterface),\n            $container- get(EmitterInterface::class)\n        );\n    }\n}  It is recommended for a module class to fetch the  EmitterInterface \nfrom the main container, instead of defining it's own since it will\navoid issues with custom emitter implementations if applicable. Also\nnote that the route must have the prefix defined by default in order to\navoid this duplication (if that is your thing, but do keep in mind that\nthe intent behind this kind of modules is that a module can and should\nbe able to function as it's own application and not only as a module of\nanother). Once the initial testing has been performed a CLI application\nwill be developed allowing for the generation of module classes from\nexisting applications, which will empower use-cases such as minimal blog\nto be embedded inside another application at a prefix; as well as\ninstall/uninstall steps, but that is TBD as of now so don't rely\ncompletely on that, but do keep in mind that the reasoning behind the\nmodules is here to stay.", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/#recommendations", 
            "text": "Majority of the following points are intended to serve only as\nguide lines, and developers are free to ignore them, but complying\nwill ensure consistency between module structure and workflow, hence\nimproving experience    A module is a component of an application or website that provides visitor\n access to specific part of the website, a module should not only provide\n libraries and/or frameworks (for that part please stick with composer, see\n  composer documentation for information on how to use VCS for package distribution ).    A module should provide contact information to allow users to report issues\n make/discuss feature requests and/or disclose security vulnerabilities.    Another highly recommended thing to do is follow the PHP standards (PSR) to\n ensure compatibility with other libraries/modules/frameworks, that the\n user might be using within their application, out of the box.    Following the HTTP standards is also a good thing to do, since that will\n increase the flexibility of user implementations in a magnitude. Example:\n if you provide  Last-Modified  header and check for  If-Modified-Since \n the application may become more performant, since no data should be\n transfered.    As a developer you should try to keep the dependencies for your module\n as minimal as possible so users do not get bloated with dependencies,\n also as a added benefit you lower the risk of your module breaking, because\n of external changes.    A module, should not provide/enforce specific view components, since it\n may break application/website functionality/appearance, rather a API backend\n should be previded with information/tutorials/examples on how to communicate\n with said backend in a consistent way. *Design your modules for front ends\n built using modern frameworks like, ReactJS and Angular2 or other similar ones.    A module should be kept as small and self-contained as possible. For example\n if a module is intended to provide blogging functionality it should (where applicable)\n be split in separate compoenets for  posts ,  comments ,  editing . That way users\n would have the opportunity to mix and match compoents that are compatible or directly\n write a custom one to fit their needs or bridge gaps between different modules.    A module may communicate with existing services, but it is recommended to provide\n information with which services/3rd parties information is exchanged and for what\n purposes.    A module should not intend to modify files inside or outside of itself, when such\n configuration is required it should provide detailed information what, where and why\n should be changed for the user to configure (or optionally a script can be provided,\n but not automatically executed)    Optionally your module may provide a UI, but it should be implemented in such a way\n that it's styling should be easily changeable since, different people have different\n tastes.", 
            "title": "Recommendations"
        }
    ]
}