{
    "docs": [
        {
            "location": "/", 
            "text": "About\n\n\nThis is a minimalistic PSR-2, PSR-4, PSR-7, PSR-11, PSR-15 compliant \nframework intended to provide the absolute minimum for writing a\nweb application that utilizes the middleware concept as well as other \naccepted standards from the community. There are no plans at least for \nnow to provide functionality that will allow usages other than web \noriented.\n\n\nIt implements the PSR-15 spec (\nhttp-interop/http-middleware: 0.2\n) as\nit is the latest present.\n\n\nForeword\n\n\nThe drive behind the project was to write cleaner code utilizing php7\nfeatures + standards + learning new stuff and I think that it is worth\nsharing, if not for people building the world's next best application at\nleast to help those, like me, who are looking in to get new idea, \nunderstand some things or in general see how some things can be done or\nat the worst case scenario, how NOT to do certain stuff :D.\n\n\nDevelopment tips\n\n\nIn the development environment and when testing the php.ini directives\n\nzend.assertions\n and \nassert.exceptions\n should both be set to 1, since\nthe internals of the framework actually utilise the exceptions to warn \nabout development mistakes, but are intended to be turned off on \nproduction in order to squeeze maximum performance out of the framework\nby disabling some checks. An example of such is the container that will \nthrow when a dependency does not match it's key type (if class/interface\nname is used) and when a factory does not implement \nFactoryInterface\n,\nwhen assertions are on, but will fail, if they are disabled, since those\nare not things that should be affected by user input or any other input \nfor that matter (they are developer made mistakes).\n\n\nDependency Injection\n\n\nThe framework comes with a capable DI container that can resolve \ndependencies using a combination of a interface-class map, class-factory \nmap and also reflection-based type resolution. These should be enough\nfor any developer to achieve everything necessary without relying on \nexternal sources, such as JSON, XML or annotations (although any usage \nin combination with annotations/AOP is encouraged, but not without a \nvery good reason to be used, since it can make the code very cryptic,\nerror prone and hard to understand/maintain/pickup for others.\n\n\nRouting\n\n\nAlso a routing component is presented as well, which can be altered \nwithout changing the actual implementation through the use of \nparsers and matchers:\n\n\n\n\n\n\nParsers\n - They are responsible to prepare the route to be \n  processed later when matching against the current request URI.\n\n\n\n\n\n\nMatchers\n - are responsible for making the heavy lifting in terms \n  of extracting parameters if applicable and determining if the current \n  request URI matches the offered pattern", 
            "title": "Intro"
        }, 
        {
            "location": "/#about", 
            "text": "This is a minimalistic PSR-2, PSR-4, PSR-7, PSR-11, PSR-15 compliant \nframework intended to provide the absolute minimum for writing a\nweb application that utilizes the middleware concept as well as other \naccepted standards from the community. There are no plans at least for \nnow to provide functionality that will allow usages other than web \noriented.  It implements the PSR-15 spec ( http-interop/http-middleware: 0.2 ) as\nit is the latest present.", 
            "title": "About"
        }, 
        {
            "location": "/#foreword", 
            "text": "The drive behind the project was to write cleaner code utilizing php7\nfeatures + standards + learning new stuff and I think that it is worth\nsharing, if not for people building the world's next best application at\nleast to help those, like me, who are looking in to get new idea, \nunderstand some things or in general see how some things can be done or\nat the worst case scenario, how NOT to do certain stuff :D.", 
            "title": "Foreword"
        }, 
        {
            "location": "/#development-tips", 
            "text": "In the development environment and when testing the php.ini directives zend.assertions  and  assert.exceptions  should both be set to 1, since\nthe internals of the framework actually utilise the exceptions to warn \nabout development mistakes, but are intended to be turned off on \nproduction in order to squeeze maximum performance out of the framework\nby disabling some checks. An example of such is the container that will \nthrow when a dependency does not match it's key type (if class/interface\nname is used) and when a factory does not implement  FactoryInterface ,\nwhen assertions are on, but will fail, if they are disabled, since those\nare not things that should be affected by user input or any other input \nfor that matter (they are developer made mistakes).", 
            "title": "Development tips"
        }, 
        {
            "location": "/#dependency-injection", 
            "text": "The framework comes with a capable DI container that can resolve \ndependencies using a combination of a interface-class map, class-factory \nmap and also reflection-based type resolution. These should be enough\nfor any developer to achieve everything necessary without relying on \nexternal sources, such as JSON, XML or annotations (although any usage \nin combination with annotations/AOP is encouraged, but not without a \nvery good reason to be used, since it can make the code very cryptic,\nerror prone and hard to understand/maintain/pickup for others.", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/#routing", 
            "text": "Also a routing component is presented as well, which can be altered \nwithout changing the actual implementation through the use of \nparsers and matchers:    Parsers  - They are responsible to prepare the route to be \n  processed later when matching against the current request URI.    Matchers  - are responsible for making the heavy lifting in terms \n  of extracting parameters if applicable and determining if the current \n  request URI matches the offered pattern", 
            "title": "Routing"
        }, 
        {
            "location": "/setup/", 
            "text": "Getting started\n\n\nIn this section we'll get through a simple hello world app to help you\nget a grip around the concepts of the framework as well as how to \nset it up and work on it.\n\n\n1st thing is the index file, it is the entry point for the application.\nThe application consists of middleware, which if you are not familiar \nwith you should think of as onion's layers (now you get where the name \ncomes from). See:\n\n\n\n\n\n\nPSR-15 Specification\n\n\n\n\n\n\nWhy Care About PHP Middleware?\n by \nPhil Phil Sturgeon\n\n\n\n\n\n\nChosing single pass ensures no funny business will be going inside the \nmiddleware you use, and you can be sure that the response you return \nwill be consistently handled, and you will not have to keep track of\nthe double-pass response object, that may or may not have some specific \nheaders set by any of the middleware called before your \"controller\".\n\n\nInstallation\n\n\nSo with that being said, lets jump right in with the installation \nand setup of the \"hello world\" project:\n\n\n\n\ncomposer require onion/framework:1.0.0-beta\n\n\nCreate the public directory one that will be exposed by the web \nserver, referred to as \npublic\n in this example\n\n\n\n\nIn it, create a file named \nindex.php\n and inside of it paste the \nfollowing:\n\n\n```\n\n?php\ndeclare(strict_types=1);\nrequire_once \nDIR\n . '/../vendor/autoload.php';\nuse Onion\\Framework;\n\n\n$container = new Framework\\Dependency\\Container([]);\n\n\n$app = $container-\nget(Framework\\Application\\Application::class);\n$app-\nrun(\n    $container-\nget(\\Psr\\Http\\Message\\ServerRequestInterface::class)\n);\n```\n\n\nThis is the minimal required code in order to set up the application \nentry point.\n\n\n\n\n\n\nTo test it run the following: \nphp -S localhost:12345 -t public/\n \ninside the projects directory, that will start the PHP built-in server\nand will make the application code accessible on: \n\nlocalhost:12345\n\n\n\n\n\n\n\n\nDependencies\n\n\nNow if you open the link with your browser, you will see there is an \nexception being thrown, similar to (if no the same as):\n\n\n\n\nUncaught Onion\\Framework\\Dependency\\Exception\\ContainerErrorException: Unable to find match for type: \"Interop\\Http\\Middleware\\DelegateInterface\". Consider using a factory\n...\n\n\n\n\nWhat this means is that the container is unable to resolve the \ndependency of \nDelegateInterface\n, this sucks big time, now before you \nstart digging in the code, hold on for a sec and lets see what happens\nin our \nindex.php\n file.\n\n\n\n\n\n\nL2-L4\n - We declare that we will use strict types, require the \ncomposer autoloader and localize the namespace (a bit shorter to write)\n\n\n\n\n\n\nL6\n - We initialize the DI container without any registered \ndependencies (pay attention to the empty array passed as argument), \nwhich will force the container to use reflection in order to look-up \ndependencies recursively as deep as it can go.\n\n\n\n\n\n\nL8\n - We attempt to retrieve the \nApplication\n class from the \ncontainer (This is where the exception gets thrown)\n\n\n\n\n\n\nL9-L11\n - We attempt to run the application by passing it the \ncurrent request object, again retrieved from the container\n\n\n\n\n\n\nIn order to learn more about the \nDelegateInterface\n make sure you read \nthe PSR-15 spec. Now in the implementation the Application object \nreceives 2 arguments in it's constructor:\n\n\n\n\nDelegateInterface\n - Is a delegate which has all of the global \n  middleware chained inside it.\n\n\nEmitterInterface\n - Is responsible for emitting our response \n  \"on the way out\"\u2122, which is either one of the implementations \n  available inside \nzendframework/zend-diactoros\n or your own \n  implementation.\n\n\n\n\nThe reason that the class is bound to interfaces instead of concrete \nclasses is by design and I highly encourage you to work your code around\nthat mindset, since this enforces the \n\nL\n from \n\nSOLID\n\n\nNow let's update our index to include the \nDelegateInterface\n and \n\nEmitterInterface\n in a dependency mapping so that our container knows\nwhat to return when we need any of those dependencies.\n\n\n// Replace the empty array argument for container with the following\n\n[\n    'invokables' =\n [\n        Zend\\Diactoros\\Response\\EmitterInterface::class =\n \n            Zend\\Diactoros\\Response\\SapiEmitter::class\n    ],\n    'factories' =\n [\n        Interop\\Http\\Middleware\\DelegateInterface::class =\n \n            Framework\\Application\\Factory\\GlobalDelegateFactory::class\n    ]\n]\n\n\n\n\n\n\nMiddleware\n\n\nNow if you run the application you will notice that there is an entierly\ndifferent error, about missing \nmiddleware\n key.\n\n\n\n\nUncaught Onion\\Framework\\Dependency\\Exception\\UnknownDependency: Unable to resolve \"middleware\"\n\n\n\n\nThis is because the \nGlobalDelegateFactory\n expects to see \nmiddleware\n\nkey inside our container and use it in order to build the necessary call\nstack. Lets add it, but leave it empty. Add \n'middleware' =\n []\n after\nthe factory definition in the top level array.\n\n\n\n\nReturn value of Onion\\Framework\\Application\\Factory\\GlobalDelegateFactory::build() must be an instance of Interop\\Http\\Middleware\\DelegateInterface, null returned\n\n\n\n\nIs pretty self explanatory, but why you ask? Well, the factory needs at \nleast one entry inside the \nmiddleware\n in order to build a \n\nDelegateInterface\n with it, just keep in mind it MUST be an instance of \neither \nInterop\\Http\\Middleware\\MiddlewareInterface\n or\n\nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n and since we are \nbuilding a server application (not a HTTP client) we will pass in an \nargument that is vital to any HTTP application - a router.\nBut to avoid the error steps above, I will directly tell you that you \nhave to define those in order to get it going. Update the array to look \nlike the following:\n\n\n[\n    'invokables' =\n [\n        Zend\\Diactoros\\Response\\EmitterInterface::class =\n\n            Zend\\Diactoros\\Response\\SapiEmitter::class,\n        Framework\\Router\\Interfaces\\ParserInterface::class =\n\n            Framework\\Router\\Parsers\\Flat::class,\n        Framework\\Router\\Interfaces\\MatcherInterface::class =\n\n            Framework\\Router\\Matchers\\Strict::class\n    ],\n    'factories' =\n [\n        Interop\\Http\\Middleware\\DelegateInterface::class =\n\n            Framework\\Application\\Factory\\GlobalDelegateFactory::class,\n        Framework\\Router\\Interfaces\\RouterInterface::class =\n\n            Framework\\Router\\Factory\\RouterFactory::class,\n        Psr\\Http\\Message\\ServerRequestInterface::class =\n\n            Framework\\Http\\Factory\\ServerRequestFactory::class\n    ],\n    'middleware' =\n [\n        Framework\\Router\\Interfaces\\RouterInterface::class\n    ],\n    'routes' =\n []\n]\n\n\n\n\n\n\nRouting\n\n\nSince our router implements the \nServerMiddlewareInterface\n we can pass\nit without any other boilerplate to the middleware section and the\nother 2 dependencies inside the invokables section are for making it \nwork.\n\n\n\n\n\n\nFramework\\Router\\Interfaces\\ParserInterface\n is responsible for \n translating the route definitions to mathcer understandable string\n\n\n\n\n\n\nFramework\\Router\\Interfaces\\MatcherInterface\n is the one performing\n the matching in order to see if the current request URI matches a route\n\n\n\n\n\n\nIn this case we are using the flat matcher, which returns the pattern as\nis and the strict matcher that performs \na === b\n kind of checks.\n\n\n\n\nNow if we refresh the page we will se that there will be an exception:\n\n\n\n\nUncaught Onion\\Framework\\Router\\Exceptions\\NotFoundException: No route available to handle \"/\"\n\n\n\n\nNow lets create our first controller, add autoloading for the \n\nApplication\n namespace to composer and inside \n\nsrc/Controllers/DummyController.php\n paste the following:\n\n\n?php\ndeclare(strict_types=1);\n\nnamespace App\\Controllers;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\nclass DummyController implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate = null)\n    {\n        return new TextResponse('Hello, World!');\n    }\n}\n\n\n\n\nNow that you are done, lets add the controller to the \nroutes\n:\n\n\n// .. other definitions\n'routes' =\n [\n  [\n    'pattern' =\n '/',\n    'middleware' =\n [\n        App\\Controllers\\DummyMiddleware::class\n    ]\n  ]\n]\n\n\n\n\n\n\nFQCN\n - \nFully Qualified Class Name\n\n\n\n\nNow if all went well you should not see any further errors when you \nrefresh the page, but rather the text 'Hello, World!' should be \ndisplayed and the response should be sent with \n\nContent-Type: text/plain\n header.\n\n\nThis is the minimal required setup needed in order to setup an \napplication using onion framework and from here you can conquer the \nworld! Check other sections from the documentation to get more in-depth \nunderstanding/knowledge of the routing capabilities, the concept of \nmodules and everything else.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/setup/#getting-started", 
            "text": "In this section we'll get through a simple hello world app to help you\nget a grip around the concepts of the framework as well as how to \nset it up and work on it.  1st thing is the index file, it is the entry point for the application.\nThe application consists of middleware, which if you are not familiar \nwith you should think of as onion's layers (now you get where the name \ncomes from). See:    PSR-15 Specification    Why Care About PHP Middleware?  by  Phil Phil Sturgeon    Chosing single pass ensures no funny business will be going inside the \nmiddleware you use, and you can be sure that the response you return \nwill be consistently handled, and you will not have to keep track of\nthe double-pass response object, that may or may not have some specific \nheaders set by any of the middleware called before your \"controller\".", 
            "title": "Getting started"
        }, 
        {
            "location": "/setup/#installation", 
            "text": "So with that being said, lets jump right in with the installation \nand setup of the \"hello world\" project:   composer require onion/framework:1.0.0-beta  Create the public directory one that will be exposed by the web \nserver, referred to as  public  in this example   In it, create a file named  index.php  and inside of it paste the \nfollowing:  ``` ?php\ndeclare(strict_types=1);\nrequire_once  DIR  . '/../vendor/autoload.php';\nuse Onion\\Framework;  $container = new Framework\\Dependency\\Container([]);  $app = $container- get(Framework\\Application\\Application::class);\n$app- run(\n    $container- get(\\Psr\\Http\\Message\\ServerRequestInterface::class)\n);\n```  This is the minimal required code in order to set up the application \nentry point.    To test it run the following:  php -S localhost:12345 -t public/  \ninside the projects directory, that will start the PHP built-in server\nand will make the application code accessible on:  localhost:12345", 
            "title": "Installation"
        }, 
        {
            "location": "/setup/#dependencies", 
            "text": "Now if you open the link with your browser, you will see there is an \nexception being thrown, similar to (if no the same as):   Uncaught Onion\\Framework\\Dependency\\Exception\\ContainerErrorException: Unable to find match for type: \"Interop\\Http\\Middleware\\DelegateInterface\". Consider using a factory\n...   What this means is that the container is unable to resolve the \ndependency of  DelegateInterface , this sucks big time, now before you \nstart digging in the code, hold on for a sec and lets see what happens\nin our  index.php  file.    L2-L4  - We declare that we will use strict types, require the \ncomposer autoloader and localize the namespace (a bit shorter to write)    L6  - We initialize the DI container without any registered \ndependencies (pay attention to the empty array passed as argument), \nwhich will force the container to use reflection in order to look-up \ndependencies recursively as deep as it can go.    L8  - We attempt to retrieve the  Application  class from the \ncontainer (This is where the exception gets thrown)    L9-L11  - We attempt to run the application by passing it the \ncurrent request object, again retrieved from the container    In order to learn more about the  DelegateInterface  make sure you read \nthe PSR-15 spec. Now in the implementation the Application object \nreceives 2 arguments in it's constructor:   DelegateInterface  - Is a delegate which has all of the global \n  middleware chained inside it.  EmitterInterface  - Is responsible for emitting our response \n  \"on the way out\"\u2122, which is either one of the implementations \n  available inside  zendframework/zend-diactoros  or your own \n  implementation.   The reason that the class is bound to interfaces instead of concrete \nclasses is by design and I highly encourage you to work your code around\nthat mindset, since this enforces the  L  from  SOLID  Now let's update our index to include the  DelegateInterface  and  EmitterInterface  in a dependency mapping so that our container knows\nwhat to return when we need any of those dependencies.  // Replace the empty array argument for container with the following\n\n[\n    'invokables' =  [\n        Zend\\Diactoros\\Response\\EmitterInterface::class =  \n            Zend\\Diactoros\\Response\\SapiEmitter::class\n    ],\n    'factories' =  [\n        Interop\\Http\\Middleware\\DelegateInterface::class =  \n            Framework\\Application\\Factory\\GlobalDelegateFactory::class\n    ]\n]", 
            "title": "Dependencies"
        }, 
        {
            "location": "/setup/#middleware", 
            "text": "Now if you run the application you will notice that there is an entierly\ndifferent error, about missing  middleware  key.   Uncaught Onion\\Framework\\Dependency\\Exception\\UnknownDependency: Unable to resolve \"middleware\"   This is because the  GlobalDelegateFactory  expects to see  middleware \nkey inside our container and use it in order to build the necessary call\nstack. Lets add it, but leave it empty. Add  'middleware' =  []  after\nthe factory definition in the top level array.   Return value of Onion\\Framework\\Application\\Factory\\GlobalDelegateFactory::build() must be an instance of Interop\\Http\\Middleware\\DelegateInterface, null returned   Is pretty self explanatory, but why you ask? Well, the factory needs at \nleast one entry inside the  middleware  in order to build a  DelegateInterface  with it, just keep in mind it MUST be an instance of \neither  Interop\\Http\\Middleware\\MiddlewareInterface  or Interop\\Http\\Middleware\\ServerMiddlewareInterface  and since we are \nbuilding a server application (not a HTTP client) we will pass in an \nargument that is vital to any HTTP application - a router.\nBut to avoid the error steps above, I will directly tell you that you \nhave to define those in order to get it going. Update the array to look \nlike the following:  [\n    'invokables' =  [\n        Zend\\Diactoros\\Response\\EmitterInterface::class = \n            Zend\\Diactoros\\Response\\SapiEmitter::class,\n        Framework\\Router\\Interfaces\\ParserInterface::class = \n            Framework\\Router\\Parsers\\Flat::class,\n        Framework\\Router\\Interfaces\\MatcherInterface::class = \n            Framework\\Router\\Matchers\\Strict::class\n    ],\n    'factories' =  [\n        Interop\\Http\\Middleware\\DelegateInterface::class = \n            Framework\\Application\\Factory\\GlobalDelegateFactory::class,\n        Framework\\Router\\Interfaces\\RouterInterface::class = \n            Framework\\Router\\Factory\\RouterFactory::class,\n        Psr\\Http\\Message\\ServerRequestInterface::class = \n            Framework\\Http\\Factory\\ServerRequestFactory::class\n    ],\n    'middleware' =  [\n        Framework\\Router\\Interfaces\\RouterInterface::class\n    ],\n    'routes' =  []\n]", 
            "title": "Middleware"
        }, 
        {
            "location": "/setup/#routing", 
            "text": "Since our router implements the  ServerMiddlewareInterface  we can pass\nit without any other boilerplate to the middleware section and the\nother 2 dependencies inside the invokables section are for making it \nwork.    Framework\\Router\\Interfaces\\ParserInterface  is responsible for \n translating the route definitions to mathcer understandable string    Framework\\Router\\Interfaces\\MatcherInterface  is the one performing\n the matching in order to see if the current request URI matches a route    In this case we are using the flat matcher, which returns the pattern as\nis and the strict matcher that performs  a === b  kind of checks.   Now if we refresh the page we will se that there will be an exception:   Uncaught Onion\\Framework\\Router\\Exceptions\\NotFoundException: No route available to handle \"/\"   Now lets create our first controller, add autoloading for the  Application  namespace to composer and inside  src/Controllers/DummyController.php  paste the following:  ?php\ndeclare(strict_types=1);\n\nnamespace App\\Controllers;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\nclass DummyController implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate = null)\n    {\n        return new TextResponse('Hello, World!');\n    }\n}  Now that you are done, lets add the controller to the  routes :  // .. other definitions\n'routes' =  [\n  [\n    'pattern' =  '/',\n    'middleware' =  [\n        App\\Controllers\\DummyMiddleware::class\n    ]\n  ]\n]   FQCN  -  Fully Qualified Class Name   Now if all went well you should not see any further errors when you \nrefresh the page, but rather the text 'Hello, World!' should be \ndisplayed and the response should be sent with  Content-Type: text/plain  header.  This is the minimal required setup needed in order to setup an \napplication using onion framework and from here you can conquer the \nworld! Check other sections from the documentation to get more in-depth \nunderstanding/knowledge of the routing capabilities, the concept of \nmodules and everything else.", 
            "title": "Routing"
        }, 
        {
            "location": "/routing/", 
            "text": "Introduction\n\n\nTHe built in router uses the strategy pattern in order to achieve \nmaximum flexibility in terms of pattern syntax \n capabilities. \n\n\nIn order to provide routes to the router using the build-in factory\nthe key \nroutes\n must be defined inside the DI container and look like \nthe following:\n\n\nreturn [\n    // .. other container definitions\n    'routes' =\n [\n        [\n            'pattern' =\n '/',\n            'middleware' =\n [\n                /**\n                 * Implementations of ServerMiddlewareInterface specific\n                 * for the current route\n                 */\n            ],\n            'methods' =\n ['GET', 'HEAD'], // Optional, supported methods\n            'name' =\n '' // Optional, used with `getRouteByName`\n        ], [\n            // .. another route definition\n        ]\n    ]\n];\n\n\n\n\nKeep in mind that \npattern\n and \nmiddleware\n MUST be present, otherwise \nexception will be thrown.\n\n\nParsers\n\n\nA route parser is responsible to translate the route definition key \n\npattern\n to a matcher processable representation, at the moment the \nonly real usage of it is in the \nRegex\n parser and matcher pair, where\nThe parser allows the usage of route patterns such as \n\n/articles[/[id:*]]\n, which allow the matcher to extract the parameter\n\nid\n and also match even if it is omitted, resulting in the route \ndefined being responsible for handling \n/articles\n as well as \n\n/articles/5\n and \n/articles/why-chose-onion-framework\n\n\nMatchers\n\n\nA matcher is responsible for solely checking if the current request URI\nmatches the route pattern provided (as the name suggests) and in the \ncase of the \nRegex\n pair extract the parameters form the URI and return \nthem. \n\n\nAvailable pairs\n\n\nThe available pairs are listed below in the 'Parser' =\n 'Matcher' syntax\n\n\n\n\nFlat\n =\n \nStrict\n\n\nRegex\n =\n \nRegex\n\n\n\n\nThere is also a single matcher, that does not correspond to any parser \nand can be used with both parsers (although might be a better fit for \nthe \nFlat\n rather than \nRegex\n, but that depends on the implementation).\nInternally it is used only inside the \nModuleDelegateFactory\n, which is\na special case discussed in the \nModules\n section, but if it is fitting \nyour use case feel free to use it, but beware that it uses \nsubstr\n to \ndetermine if a prefix is present so using it with a route with pattern\n\n/\n will result in all routes being passed to that controller, which is \nraraly the intended behaviour.", 
            "title": "Routing"
        }, 
        {
            "location": "/routing/#introduction", 
            "text": "THe built in router uses the strategy pattern in order to achieve \nmaximum flexibility in terms of pattern syntax   capabilities.   In order to provide routes to the router using the build-in factory\nthe key  routes  must be defined inside the DI container and look like \nthe following:  return [\n    // .. other container definitions\n    'routes' =  [\n        [\n            'pattern' =  '/',\n            'middleware' =  [\n                /**\n                 * Implementations of ServerMiddlewareInterface specific\n                 * for the current route\n                 */\n            ],\n            'methods' =  ['GET', 'HEAD'], // Optional, supported methods\n            'name' =  '' // Optional, used with `getRouteByName`\n        ], [\n            // .. another route definition\n        ]\n    ]\n];  Keep in mind that  pattern  and  middleware  MUST be present, otherwise \nexception will be thrown.", 
            "title": "Introduction"
        }, 
        {
            "location": "/routing/#parsers", 
            "text": "A route parser is responsible to translate the route definition key  pattern  to a matcher processable representation, at the moment the \nonly real usage of it is in the  Regex  parser and matcher pair, where\nThe parser allows the usage of route patterns such as  /articles[/[id:*]] , which allow the matcher to extract the parameter id  and also match even if it is omitted, resulting in the route \ndefined being responsible for handling  /articles  as well as  /articles/5  and  /articles/why-chose-onion-framework", 
            "title": "Parsers"
        }, 
        {
            "location": "/routing/#matchers", 
            "text": "A matcher is responsible for solely checking if the current request URI\nmatches the route pattern provided (as the name suggests) and in the \ncase of the  Regex  pair extract the parameters form the URI and return \nthem.", 
            "title": "Matchers"
        }, 
        {
            "location": "/routing/#available-pairs", 
            "text": "The available pairs are listed below in the 'Parser' =  'Matcher' syntax   Flat  =   Strict  Regex  =   Regex   There is also a single matcher, that does not correspond to any parser \nand can be used with both parsers (although might be a better fit for \nthe  Flat  rather than  Regex , but that depends on the implementation).\nInternally it is used only inside the  ModuleDelegateFactory , which is\na special case discussed in the  Modules  section, but if it is fitting \nyour use case feel free to use it, but beware that it uses  substr  to \ndetermine if a prefix is present so using it with a route with pattern /  will result in all routes being passed to that controller, which is \nraraly the intended behaviour.", 
            "title": "Available pairs"
        }, 
        {
            "location": "/modules/", 
            "text": "Introduction\n\n\nModules are not a new concept in the development world, nor they re new \nto the PHP frameworks/applications. The implementation used here is not\ntoo different from what has already been implemented in other frameworks\nbut the intent is clear and is aimed at enforcing the separation of \napplications in logical parts, rather than having module provide \nhelper functionality (although they can also be used in that way, but \nmight fee less intuitive)\n\n\nSetup\n\n\nA module should have it's logic as self-contained as possible, except \nfor configurations, since that will change from application to \napplication.\n\n\nThe only requirement in order to ensure consistency (as of now it is not\nenforced) is for the module to serve as a factory that MUST return\ninstance of \nApplication\n, since application is a middleware it does not\nintroduce a very specific behaviour, except maybe for having a separate\nmiddleware delegate defined and a separate router for the module itself.\n\n\nInternally the \nModuleDelegateFactory\n is building a router with every\ninstance \nApplication\n assigned it's own prefix inside a \nmodule\n key.\n\n\nConfiguration\n\n\nThe minimal configuration to the container is:\n\n\nreturn [\n    // .. other configuration\n    'modules' =\n [\n        '/api' =\n MyApp\\API\\Module::class\n    ]\n]\n\n\n\n\nAn example module class:\n\n\nnamespace MyApp\\API;\n\nuse Interop\\Container\\ContainerInterface;\nuse Onion\\Framework\\Application\\Application;\nuse Onion\\Framework\\Application\\Interfaces\\ModuleInterface;\n\nclass Module implements ModuleInterface\n{\n    private function getConfigurations(): array\n    {\n        return [\n            'routes' =\n [\n                [\n                    'pattern' =\n '/api/users',\n                    'middleware' =\n [\n                        UsersApiController::class\n                    ]\n                ]\n            ]\n        ];\n    }\n\n    public function build(ContainerInterface $container): Application\n    {\n        // Logic of creating a router ONLY with module-specific routes\n        return new Application\n            $router,\n            $container-\nget(EmitterInterface::class)\n        );\n    }\n}\n\n\n\n\nIt is recommended for a module class to fetch the \nEmitterInterface\n \nfrom the main container, instead of defining it's own since it will \navoid issues with custom emitter implementations if applicable. Also\nnote that the route must have the prefix defined by default in order to\navoid this duplication (if that is your thing, but do keep in mind that\nthe intent behind this kind of modules is that a module can and should \nbe able to function as it's own application and not only as a module of\nanother). Once the initial testing has been performed a CLI application\nwill be developed allowing for the generation of module classes from \nexisting applications, which will empower use-cases such as minimal blog\nto be embedded inside another application at a prefix; as well as \ninstall/uninstall steps, but that is TBD as of now so don't rely \ncompletely on that, but do keep in mind that the reasoning behind the\nmodules is here to stay.\n\n\n This is only intended to be a WEB framework and not a multi-purpose \none that can aid building of CLI apps", 
            "title": "Modules"
        }, 
        {
            "location": "/modules/#introduction", 
            "text": "Modules are not a new concept in the development world, nor they re new \nto the PHP frameworks/applications. The implementation used here is not\ntoo different from what has already been implemented in other frameworks\nbut the intent is clear and is aimed at enforcing the separation of \napplications in logical parts, rather than having module provide \nhelper functionality (although they can also be used in that way, but \nmight fee less intuitive)", 
            "title": "Introduction"
        }, 
        {
            "location": "/modules/#setup", 
            "text": "A module should have it's logic as self-contained as possible, except \nfor configurations, since that will change from application to \napplication.  The only requirement in order to ensure consistency (as of now it is not\nenforced) is for the module to serve as a factory that MUST return\ninstance of  Application , since application is a middleware it does not\nintroduce a very specific behaviour, except maybe for having a separate\nmiddleware delegate defined and a separate router for the module itself.  Internally the  ModuleDelegateFactory  is building a router with every\ninstance  Application  assigned it's own prefix inside a  module  key.", 
            "title": "Setup"
        }, 
        {
            "location": "/modules/#configuration", 
            "text": "The minimal configuration to the container is:  return [\n    // .. other configuration\n    'modules' =  [\n        '/api' =  MyApp\\API\\Module::class\n    ]\n]  An example module class:  namespace MyApp\\API;\n\nuse Interop\\Container\\ContainerInterface;\nuse Onion\\Framework\\Application\\Application;\nuse Onion\\Framework\\Application\\Interfaces\\ModuleInterface;\n\nclass Module implements ModuleInterface\n{\n    private function getConfigurations(): array\n    {\n        return [\n            'routes' =  [\n                [\n                    'pattern' =  '/api/users',\n                    'middleware' =  [\n                        UsersApiController::class\n                    ]\n                ]\n            ]\n        ];\n    }\n\n    public function build(ContainerInterface $container): Application\n    {\n        // Logic of creating a router ONLY with module-specific routes\n        return new Application\n            $router,\n            $container- get(EmitterInterface::class)\n        );\n    }\n}  It is recommended for a module class to fetch the  EmitterInterface  \nfrom the main container, instead of defining it's own since it will \navoid issues with custom emitter implementations if applicable. Also\nnote that the route must have the prefix defined by default in order to\navoid this duplication (if that is your thing, but do keep in mind that\nthe intent behind this kind of modules is that a module can and should \nbe able to function as it's own application and not only as a module of\nanother). Once the initial testing has been performed a CLI application\nwill be developed allowing for the generation of module classes from \nexisting applications, which will empower use-cases such as minimal blog\nto be embedded inside another application at a prefix; as well as \ninstall/uninstall steps, but that is TBD as of now so don't rely \ncompletely on that, but do keep in mind that the reasoning behind the\nmodules is here to stay.   This is only intended to be a WEB framework and not a multi-purpose \none that can aid building of CLI apps", 
            "title": "Configuration"
        }
    ]
}