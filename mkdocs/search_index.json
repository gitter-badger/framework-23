{
    "docs": [
        {
            "location": "/", 
            "text": "About\n\n\nThis is a minimalistic PSR-2, PSR-4, PSR-7, PSR-11, PSR-15 compliant\nframework intended to provide the absolute minimum for writing a\nweb application that utilizes the middleware concept as well as other\naccepted standards from the community. There are no plans at least for\nnow to provide functionality that will allow usages other than web\noriented.\n\n\nIt implements the PSR-15 spec (\nhttp-interop/http-middleware: dev-master\n)\nsince some changes ware made that made the client middleware obsolete.\n\n\nForeword\n\n\nThe drive behind the project was to write cleaner code utilizing php7\nfeatures + standards + learning new stuff and I think that it is worth\nsharing, if not for people building the world's next best application at\nleast to help those, like me, who are looking in to get new idea,\nunderstand some things or in general see how some things can be done or\nat the worst case scenario, how NOT to do certain stuff :D.\n\n\nDevelopment tips\n\n\nIn the development environment and when testing the php.ini directives\n\nzend.assertions\n and \nassert.exceptions\n should both be set to 1, since\nthe internals of the framework actually utilise the exceptions to warn\nabout development mistakes, but are intended to be turned off on\nproduction in order to squeeze maximum performance out of the framework\nby disabling some checks. An example of such is the container that will\nthrow when a dependency does not match it's key type (if class/interface\nname is used) and when a factory does not implement \nFactoryInterface\n,\nwhen assertions are on, but will fail, if they are disabled, since those\nare not things that should be affected by user input or any other input\nfor that matter (they are developer made mistakes).\n\n\nDependency Injection\n\n\nThe framework comes with a capable DI container that can resolve\ndependencies using a combination of a interface-class map, class-factory\nmap and also reflection-based type resolution. These should be enough\nfor any developer to achieve everything necessary without relying on\nexternal sources, such as JSON, XML or annotations (although any usage\nin combination with annotations/AOP is encouraged, but not without a\nvery good reason to be used, since it can make the code very cryptic,\nerror prone and hard to understand/maintain/pickup for others.\n\n\nRouting\n\n\nAlso a routing component is presented as well, which can be altered\nwithout changing the actual implementation through the use of\nparsers and matchers:\n\n\n\n\n\n\nParsers\n - They are responsible to prepare the route to be\n  processed later when matching against the current request URI.\n\n\n\n\n\n\nMatchers\n - are responsible for making the heavy lifting in terms\n  of extracting parameters if applicable and determining if the current\n  request URI matches the offered pattern", 
            "title": "Intro"
        }, 
        {
            "location": "/#about", 
            "text": "This is a minimalistic PSR-2, PSR-4, PSR-7, PSR-11, PSR-15 compliant\nframework intended to provide the absolute minimum for writing a\nweb application that utilizes the middleware concept as well as other\naccepted standards from the community. There are no plans at least for\nnow to provide functionality that will allow usages other than web\noriented.  It implements the PSR-15 spec ( http-interop/http-middleware: dev-master )\nsince some changes ware made that made the client middleware obsolete.", 
            "title": "About"
        }, 
        {
            "location": "/#foreword", 
            "text": "The drive behind the project was to write cleaner code utilizing php7\nfeatures + standards + learning new stuff and I think that it is worth\nsharing, if not for people building the world's next best application at\nleast to help those, like me, who are looking in to get new idea,\nunderstand some things or in general see how some things can be done or\nat the worst case scenario, how NOT to do certain stuff :D.", 
            "title": "Foreword"
        }, 
        {
            "location": "/#development-tips", 
            "text": "In the development environment and when testing the php.ini directives zend.assertions  and  assert.exceptions  should both be set to 1, since\nthe internals of the framework actually utilise the exceptions to warn\nabout development mistakes, but are intended to be turned off on\nproduction in order to squeeze maximum performance out of the framework\nby disabling some checks. An example of such is the container that will\nthrow when a dependency does not match it's key type (if class/interface\nname is used) and when a factory does not implement  FactoryInterface ,\nwhen assertions are on, but will fail, if they are disabled, since those\nare not things that should be affected by user input or any other input\nfor that matter (they are developer made mistakes).", 
            "title": "Development tips"
        }, 
        {
            "location": "/#dependency-injection", 
            "text": "The framework comes with a capable DI container that can resolve\ndependencies using a combination of a interface-class map, class-factory\nmap and also reflection-based type resolution. These should be enough\nfor any developer to achieve everything necessary without relying on\nexternal sources, such as JSON, XML or annotations (although any usage\nin combination with annotations/AOP is encouraged, but not without a\nvery good reason to be used, since it can make the code very cryptic,\nerror prone and hard to understand/maintain/pickup for others.", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/#routing", 
            "text": "Also a routing component is presented as well, which can be altered\nwithout changing the actual implementation through the use of\nparsers and matchers:    Parsers  - They are responsible to prepare the route to be\n  processed later when matching against the current request URI.    Matchers  - are responsible for making the heavy lifting in terms\n  of extracting parameters if applicable and determining if the current\n  request URI matches the offered pattern", 
            "title": "Routing"
        }, 
        {
            "location": "/setup/", 
            "text": "Getting started\n\n\nIn this section we'll get through a simple hello world app to help you\nget a grip around the concepts of the framework as well as how to\nset it up and work on it.\n\n\n1st thing is the index file, it is the entry point for the application.\nThe application consists of middleware, which if you are not familiar\nwith you should think of as onion's layers (now you get where the name\ncomes from). See:\n\n\n\n\n\n\nPSR-15 Specification\n\n\n\n\n\n\nWhy Care About PHP Middleware?\n by \nPhil Phil Sturgeon\n\n\n\n\n\n\nChosing single pass ensures no funny business will be going inside the\nmiddleware you use, and you can be sure that the response you return\nwill be consistently handled, and you will not have to keep track of\nthe double-pass response object, that may or may not have some specific\nheaders set by any of the middleware called before your \"controller\".\n\n\nInstallation\n\n\nSo with that being said, lets jump right in with the installation\nand setup of the \"hello world\" project:\n\n\n\n\ncomposer require onion/framework:1.0.0-beta\n\n\nCreate the public directory one that will be exposed by the web\nserver, referred to as \npublic\n in this example\n\n\nIn it, create a file named \nindex.php\n and inside of it paste the\ncode below.\n\n\nTo test it after you copied and pasted the code run the following:\n \nphp -S localhost:12345 -t public/\n inside the projects directory,\n that will start the PHP built-in server and will make the application\n  code accessible on: \nlocalhost:12345\n\n\n\n\n    \n?php\n    declare(strict_types=1);\n    require_once __DIR__ . '/../vendor/autoload.php';\n    use Onion\\Framework;\n\n    $container = new Framework\\Dependency\\Container([]);\n\n    $app = $container-\nget(Framework\\Application\\Application::class);\n    $app-\nrun(\n        $container-\nget(\\Psr\\Http\\Message\\ServerRequestInterface::class)\n    );\n\n\n\n\nThis is the minimal required code in order to set up the application\nentry point.\n\n\n\n\nDependencies\n\n\nNow if you open the link with your browser, you will see there is an\nexception being thrown, similar to (if no the same as):\n\n\n\n\nUncaught Onion\\Framework\\Dependency\\Exception\\ContainerErrorException: Unable to find match for type: \"Interop\\Http\\Middleware\\DelegateInterface\". Consider using a factory\n...\n\n\n\n\nWhat this means is that the container is unable to resolve the\ndependency of \nDelegateInterface\n, this sucks big time, now before you\nstart digging in the code, hold on for a sec and lets see what happens\nin our \nindex.php\n file.\n\n\n\n\n\n\nL2-L4\n - We declare that we will use strict types, require the\ncomposer autoloader and localize the namespace (a bit shorter to write)\n\n\n\n\n\n\nL6\n - We initialize the DI container without any registered\ndependencies (pay attention to the empty array passed as argument),\nwhich will make the container to use only reflection in order to look-up\ndependencies recursively as deep as it can go, but since we are doing\nthings the DbC(Design by Contract) way, it has no way of knowing from\nwhere to get an implementation of the interface (contract).\n\n\n\n\n\n\nL8\n - We attempt to retrieve the \nApplication\n class from the\ncontainer (This is where the exception gets thrown)\n\n\n\n\n\n\nL9-L11\n - We attempt to run the application by passing it the\ncurrent request object, again retrieved from the container\n\n\n\n\n\n\nIn order to learn more about the \nDelegateInterface\n make sure you read\nthe PSR-15 spec. Now in the implementation the Application object\nreceives 2 arguments in it's constructor:\n\n\n\n\nDelegateInterface\n - Is a delegate which is to delegate all of\n  the global middleware.\n\n\nEmitterInterface\n - Is responsible for emitting our response\n  \"on the way out\"\u2122..\n\n\n\n\nThe reason behind binding everything to interfaces (whenever possible)\ncomes from the DbC (Design by Contract) approach, which makes the\napplication as [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)\nas possible. I can't stress enough on how important this is and you\nshould adopt and apply that mindset when possible.\n\n\nNow let's update our index to include the \nDelegateInterface\n and\n\nEmitterInterface\n in a dependency mapping so that our container knows\nwhat to return when we need any of those dependencies.\n\n\n// Replace the empty array argument for container with the following\n\n[\n    'invokables' =\n [\n        Zend\\Diactoros\\Response\\EmitterInterface::class =\n\n            Zend\\Diactoros\\Response\\SapiEmitter::class\n    ],\n    'factories' =\n [\n        Interop\\Http\\Middleware\\DelegateInterface::class =\n\n            Framework\\Application\\Factory\\GlobalDelegateFactory::class\n    ]\n]\n\n\n\n\n\n\nMiddleware\n\n\nNow if you run the application you will notice that there is an entierly\ndifferent error, about missing \nmiddleware\n key.\n\n\n\n\nUncaught Onion\\Framework\\Dependency\\Exception\\UnknownDependency: Unable to resolve \"middleware\"\n\n\n\n\nThis is because the \nGlobalDelegateFactory\n expects to see \nmiddleware\n\nkey inside our container and use it in order to build the necessary call\nstack. Lets add it, but leave it empty. Add \n'middleware' =\n []\n after\nthe factory definition in the top level array.\n\n\n\n\nReturn value of Onion\\Framework\\Application\\Factory\\GlobalDelegateFactory::build() must be an instance of Interop\\Http\\Middleware\\DelegateInterface, null returned\n\n\n\n\nIs pretty self explanatory, but why you ask? Well, the factory needs at\nleast one entry inside the \nmiddleware\n in order to build a\n\nDelegateInterface\n with it, just keep in mind it MUST be an instance of\neither \nInterop\\Http\\Middleware\\MiddlewareInterface\n or\n\nInterop\\Http\\Middleware\\ServerMiddlewareInterface\n and since we are\nbuilding a server application (not a HTTP client) we will pass in an\nargument that is vital to any HTTP application - a router.\nBut to avoid the error steps above, I will directly tell you that you\nhave to define those in order to get it going. Update the array to look\nlike the following:\n\n\n[\n    'invokables' =\n [\n        Zend\\Diactoros\\Response\\EmitterInterface::class =\n\n            Zend\\Diactoros\\Response\\SapiEmitter::class,\n        Framework\\Router\\Interfaces\\ParserInterface::class =\n\n            Framework\\Router\\Parsers\\Flat::class,\n        Framework\\Router\\Interfaces\\MatcherInterface::class =\n\n            Framework\\Router\\Matchers\\Strict::class\n    ],\n    'factories' =\n [\n        Interop\\Http\\Middleware\\DelegateInterface::class =\n\n            Framework\\Application\\Factory\\GlobalDelegateFactory::class,\n        Framework\\Router\\Interfaces\\RouterInterface::class =\n\n            Framework\\Router\\Factory\\RouterFactory::class,\n        Psr\\Http\\Message\\ServerRequestInterface::class =\n\n            Framework\\Http\\Factory\\ServerRequestFactory::class\n    ],\n    'middleware' =\n [\n        Framework\\Router\\Interfaces\\RouterInterface::class\n    ],\n    'routes' =\n []\n]\n\n\n\n\n\n\nRouting\n\n\nSince our router implements the \nServerMiddlewareInterface\n we can pass\nit without any other boilerplate to the middleware section and the\nother 2 dependencies inside the invokables section are for making it\nwork.\n\n\n\n\n\n\nFramework\\Router\\Interfaces\\ParserInterface\n is responsible for\n translating the route definitions to mathcer understandable string\n\n\n\n\n\n\nFramework\\Router\\Interfaces\\MatcherInterface\n is the one performing\n the matching in order to see if the current request URI matches a route\n\n\n\n\n\n\nIn this case we are using the flat matcher, which returns the pattern as\nis and the strict matcher that performs \na === b\n kind of checks.\n\n\n\n\nNow if we refresh the page we will se that there will be an exception:\n\n\n\n\nUncaught Onion\\Framework\\Router\\Exceptions\\NotFoundException: No route available to handle \"/\"\n\n\n\n\nNow lets create our first controller, add autoloading for the\n\nApplication\n namespace to composer and inside\n\nsrc/Controllers/DummyController.php\n paste the following:\n\n\n?php\ndeclare(strict_types=1);\n\nnamespace App\\Controllers;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\nclass DummyController implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate = null)\n    {\n        return new TextResponse('Hello, World!');\n    }\n}\n\n\n\n\nNow that you are done, lets add the controller to the \nroutes\n:\n\n\n// .. other definitions\n'routes' =\n [\n  [\n    'pattern' =\n '/',\n    'middleware' =\n [\n        App\\Controllers\\DummyMiddleware::class\n    ]\n  ]\n]\n\n\n\n\n\n\nFQCN\n - \nFully Qualified Class Name\n\n\n\n\nNow if all went well you should not see any further errors when you\nrefresh the page, but rather the text 'Hello, World!' should be\ndisplayed and the response should be sent with\n\nContent-Type: text/plain\n header.\n\n\nThis is the minimal required setup needed in order to setup an\napplication using onion framework and from here you can conquer the\nworld! Check other sections from the documentation to get more in-depth\nunderstanding/knowledge of the routing capabilities, the concept of\nmodules and everything else.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/setup/#getting-started", 
            "text": "In this section we'll get through a simple hello world app to help you\nget a grip around the concepts of the framework as well as how to\nset it up and work on it.  1st thing is the index file, it is the entry point for the application.\nThe application consists of middleware, which if you are not familiar\nwith you should think of as onion's layers (now you get where the name\ncomes from). See:    PSR-15 Specification    Why Care About PHP Middleware?  by  Phil Phil Sturgeon    Chosing single pass ensures no funny business will be going inside the\nmiddleware you use, and you can be sure that the response you return\nwill be consistently handled, and you will not have to keep track of\nthe double-pass response object, that may or may not have some specific\nheaders set by any of the middleware called before your \"controller\".", 
            "title": "Getting started"
        }, 
        {
            "location": "/setup/#installation", 
            "text": "So with that being said, lets jump right in with the installation\nand setup of the \"hello world\" project:   composer require onion/framework:1.0.0-beta  Create the public directory one that will be exposed by the web\nserver, referred to as  public  in this example  In it, create a file named  index.php  and inside of it paste the\ncode below.  To test it after you copied and pasted the code run the following:\n  php -S localhost:12345 -t public/  inside the projects directory,\n that will start the PHP built-in server and will make the application\n  code accessible on:  localhost:12345        ?php\n    declare(strict_types=1);\n    require_once __DIR__ . '/../vendor/autoload.php';\n    use Onion\\Framework;\n\n    $container = new Framework\\Dependency\\Container([]);\n\n    $app = $container- get(Framework\\Application\\Application::class);\n    $app- run(\n        $container- get(\\Psr\\Http\\Message\\ServerRequestInterface::class)\n    );  This is the minimal required code in order to set up the application\nentry point.", 
            "title": "Installation"
        }, 
        {
            "location": "/setup/#dependencies", 
            "text": "Now if you open the link with your browser, you will see there is an\nexception being thrown, similar to (if no the same as):   Uncaught Onion\\Framework\\Dependency\\Exception\\ContainerErrorException: Unable to find match for type: \"Interop\\Http\\Middleware\\DelegateInterface\". Consider using a factory\n...   What this means is that the container is unable to resolve the\ndependency of  DelegateInterface , this sucks big time, now before you\nstart digging in the code, hold on for a sec and lets see what happens\nin our  index.php  file.    L2-L4  - We declare that we will use strict types, require the\ncomposer autoloader and localize the namespace (a bit shorter to write)    L6  - We initialize the DI container without any registered\ndependencies (pay attention to the empty array passed as argument),\nwhich will make the container to use only reflection in order to look-up\ndependencies recursively as deep as it can go, but since we are doing\nthings the DbC(Design by Contract) way, it has no way of knowing from\nwhere to get an implementation of the interface (contract).    L8  - We attempt to retrieve the  Application  class from the\ncontainer (This is where the exception gets thrown)    L9-L11  - We attempt to run the application by passing it the\ncurrent request object, again retrieved from the container    In order to learn more about the  DelegateInterface  make sure you read\nthe PSR-15 spec. Now in the implementation the Application object\nreceives 2 arguments in it's constructor:   DelegateInterface  - Is a delegate which is to delegate all of\n  the global middleware.  EmitterInterface  - Is responsible for emitting our response\n  \"on the way out\"\u2122..   The reason behind binding everything to interfaces (whenever possible)\ncomes from the DbC (Design by Contract) approach, which makes the\napplication as [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)\nas possible. I can't stress enough on how important this is and you\nshould adopt and apply that mindset when possible.  Now let's update our index to include the  DelegateInterface  and EmitterInterface  in a dependency mapping so that our container knows\nwhat to return when we need any of those dependencies.  // Replace the empty array argument for container with the following\n\n[\n    'invokables' =  [\n        Zend\\Diactoros\\Response\\EmitterInterface::class = \n            Zend\\Diactoros\\Response\\SapiEmitter::class\n    ],\n    'factories' =  [\n        Interop\\Http\\Middleware\\DelegateInterface::class = \n            Framework\\Application\\Factory\\GlobalDelegateFactory::class\n    ]\n]", 
            "title": "Dependencies"
        }, 
        {
            "location": "/setup/#middleware", 
            "text": "Now if you run the application you will notice that there is an entierly\ndifferent error, about missing  middleware  key.   Uncaught Onion\\Framework\\Dependency\\Exception\\UnknownDependency: Unable to resolve \"middleware\"   This is because the  GlobalDelegateFactory  expects to see  middleware \nkey inside our container and use it in order to build the necessary call\nstack. Lets add it, but leave it empty. Add  'middleware' =  []  after\nthe factory definition in the top level array.   Return value of Onion\\Framework\\Application\\Factory\\GlobalDelegateFactory::build() must be an instance of Interop\\Http\\Middleware\\DelegateInterface, null returned   Is pretty self explanatory, but why you ask? Well, the factory needs at\nleast one entry inside the  middleware  in order to build a DelegateInterface  with it, just keep in mind it MUST be an instance of\neither  Interop\\Http\\Middleware\\MiddlewareInterface  or Interop\\Http\\Middleware\\ServerMiddlewareInterface  and since we are\nbuilding a server application (not a HTTP client) we will pass in an\nargument that is vital to any HTTP application - a router.\nBut to avoid the error steps above, I will directly tell you that you\nhave to define those in order to get it going. Update the array to look\nlike the following:  [\n    'invokables' =  [\n        Zend\\Diactoros\\Response\\EmitterInterface::class = \n            Zend\\Diactoros\\Response\\SapiEmitter::class,\n        Framework\\Router\\Interfaces\\ParserInterface::class = \n            Framework\\Router\\Parsers\\Flat::class,\n        Framework\\Router\\Interfaces\\MatcherInterface::class = \n            Framework\\Router\\Matchers\\Strict::class\n    ],\n    'factories' =  [\n        Interop\\Http\\Middleware\\DelegateInterface::class = \n            Framework\\Application\\Factory\\GlobalDelegateFactory::class,\n        Framework\\Router\\Interfaces\\RouterInterface::class = \n            Framework\\Router\\Factory\\RouterFactory::class,\n        Psr\\Http\\Message\\ServerRequestInterface::class = \n            Framework\\Http\\Factory\\ServerRequestFactory::class\n    ],\n    'middleware' =  [\n        Framework\\Router\\Interfaces\\RouterInterface::class\n    ],\n    'routes' =  []\n]", 
            "title": "Middleware"
        }, 
        {
            "location": "/setup/#routing", 
            "text": "Since our router implements the  ServerMiddlewareInterface  we can pass\nit without any other boilerplate to the middleware section and the\nother 2 dependencies inside the invokables section are for making it\nwork.    Framework\\Router\\Interfaces\\ParserInterface  is responsible for\n translating the route definitions to mathcer understandable string    Framework\\Router\\Interfaces\\MatcherInterface  is the one performing\n the matching in order to see if the current request URI matches a route    In this case we are using the flat matcher, which returns the pattern as\nis and the strict matcher that performs  a === b  kind of checks.   Now if we refresh the page we will se that there will be an exception:   Uncaught Onion\\Framework\\Router\\Exceptions\\NotFoundException: No route available to handle \"/\"   Now lets create our first controller, add autoloading for the Application  namespace to composer and inside src/Controllers/DummyController.php  paste the following:  ?php\ndeclare(strict_types=1);\n\nnamespace App\\Controllers;\n\nuse Interop\\Http\\Middleware\\DelegateInterface;\nuse Interop\\Http\\Middleware\\ServerMiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\TextResponse;\n\nclass DummyController implements ServerMiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate = null)\n    {\n        return new TextResponse('Hello, World!');\n    }\n}  Now that you are done, lets add the controller to the  routes :  // .. other definitions\n'routes' =  [\n  [\n    'pattern' =  '/',\n    'middleware' =  [\n        App\\Controllers\\DummyMiddleware::class\n    ]\n  ]\n]   FQCN  -  Fully Qualified Class Name   Now if all went well you should not see any further errors when you\nrefresh the page, but rather the text 'Hello, World!' should be\ndisplayed and the response should be sent with Content-Type: text/plain  header.  This is the minimal required setup needed in order to setup an\napplication using onion framework and from here you can conquer the\nworld! Check other sections from the documentation to get more in-depth\nunderstanding/knowledge of the routing capabilities, the concept of\nmodules and everything else.", 
            "title": "Routing"
        }, 
        {
            "location": "/routing/", 
            "text": "Introduction\n\n\nTHe built in router uses the strategy pattern in order to achieve \nmaximum flexibility in terms of pattern syntax \n capabilities. \n\n\nIn order to provide routes to the router using the build-in factory\nthe key \nroutes\n must be defined inside the DI container and look like \nthe following:\n\n\nreturn [\n    // .. other container definitions\n    'routes' =\n [\n        [\n            'pattern' =\n '/',\n            'middleware' =\n [\n                /**\n                 * Implementations of ServerMiddlewareInterface specific\n                 * for the current route\n                 */\n            ],\n            'methods' =\n ['GET', 'HEAD'], // Optional, supported methods\n            'name' =\n '' // Optional, used with `getRouteByName`\n        ], [\n            // .. another route definition\n        ]\n    ]\n];\n\n\n\n\nKeep in mind that \npattern\n and \nmiddleware\n MUST be present, otherwise \nexception will be thrown.\n\n\nParsers\n\n\nA route parser is responsible to translate the route definition key \n\npattern\n to a matcher processable representation, at the moment the \nonly real usage of it is in the \nRegex\n parser and matcher pair, where\nThe parser allows the usage of route patterns such as \n\n/articles[/[id:*]]\n, which allow the matcher to extract the parameter\n\nid\n and also match even if it is omitted, resulting in the route \ndefined being responsible for handling \n/articles\n as well as \n\n/articles/5\n and \n/articles/why-chose-onion-framework\n\n\nMatchers\n\n\nA matcher is responsible for solely checking if the current request URI\nmatches the route pattern provided (as the name suggests) and in the \ncase of the \nRegex\n pair extract the parameters form the URI and return \nthem. \n\n\nAvailable pairs\n\n\nThe available pairs are listed below in the 'Parser' =\n 'Matcher' syntax\n\n\n\n\nFlat\n =\n \nStrict\n\n\nRegex\n =\n \nRegex\n\n\n\n\nThere is also a single matcher, that does not correspond to any parser \nand can be used with both parsers (although might be a better fit for \nthe \nFlat\n rather than \nRegex\n, but that depends on the implementation).\nInternally it is used only inside the \nModuleDelegateFactory\n, which is\na special case discussed in the \nModules\n section, but if it is fitting \nyour use case feel free to use it, but beware that it uses \nsubstr\n to \ndetermine if a prefix is present so using it with a route with pattern\n\n/\n will result in all routes being passed to that controller, which is \nraraly the intended behaviour.", 
            "title": "Routing"
        }, 
        {
            "location": "/routing/#introduction", 
            "text": "THe built in router uses the strategy pattern in order to achieve \nmaximum flexibility in terms of pattern syntax   capabilities.   In order to provide routes to the router using the build-in factory\nthe key  routes  must be defined inside the DI container and look like \nthe following:  return [\n    // .. other container definitions\n    'routes' =  [\n        [\n            'pattern' =  '/',\n            'middleware' =  [\n                /**\n                 * Implementations of ServerMiddlewareInterface specific\n                 * for the current route\n                 */\n            ],\n            'methods' =  ['GET', 'HEAD'], // Optional, supported methods\n            'name' =  '' // Optional, used with `getRouteByName`\n        ], [\n            // .. another route definition\n        ]\n    ]\n];  Keep in mind that  pattern  and  middleware  MUST be present, otherwise \nexception will be thrown.", 
            "title": "Introduction"
        }, 
        {
            "location": "/routing/#parsers", 
            "text": "A route parser is responsible to translate the route definition key  pattern  to a matcher processable representation, at the moment the \nonly real usage of it is in the  Regex  parser and matcher pair, where\nThe parser allows the usage of route patterns such as  /articles[/[id:*]] , which allow the matcher to extract the parameter id  and also match even if it is omitted, resulting in the route \ndefined being responsible for handling  /articles  as well as  /articles/5  and  /articles/why-chose-onion-framework", 
            "title": "Parsers"
        }, 
        {
            "location": "/routing/#matchers", 
            "text": "A matcher is responsible for solely checking if the current request URI\nmatches the route pattern provided (as the name suggests) and in the \ncase of the  Regex  pair extract the parameters form the URI and return \nthem.", 
            "title": "Matchers"
        }, 
        {
            "location": "/routing/#available-pairs", 
            "text": "The available pairs are listed below in the 'Parser' =  'Matcher' syntax   Flat  =   Strict  Regex  =   Regex   There is also a single matcher, that does not correspond to any parser \nand can be used with both parsers (although might be a better fit for \nthe  Flat  rather than  Regex , but that depends on the implementation).\nInternally it is used only inside the  ModuleDelegateFactory , which is\na special case discussed in the  Modules  section, but if it is fitting \nyour use case feel free to use it, but beware that it uses  substr  to \ndetermine if a prefix is present so using it with a route with pattern /  will result in all routes being passed to that controller, which is \nraraly the intended behaviour.", 
            "title": "Available pairs"
        }, 
        {
            "location": "/modules/", 
            "text": "Introduction\n\n\nModules are not a new concept in the development world, nor they re new\nto the PHP frameworks/applications. The implementation used here is not\ntoo different from what has already been implemented in other frameworks\nbut the intent is clear and is aimed at enforcing the separation of\napplications in logical parts, rather than having module provide\nhelper functionality (although they can also be used in that way, but\nmight fee less intuitive)\n\n\nSetup\n\n\nA module must be as self-contained as possible. It is up to the module\ndeveloper to determine what configuration is comming from where, but\nmandatory (such as internal dependency mapping) should be defined and\nmight even be appropriate to have it hardcoded, but optional things,\nsuch as database connection settings, etc. should be retrieved from the\nmain application container via an acceptable method explained inside\nmodule's \nreadme\n on \ninstallation\n files.\n\n\nA module should have it's logic as self-contained as possible, except\nfor configurations, since that will change from application to\napplication.\n\n\nThe only requirement in order to ensure consistency (as of now it is not\nenforced) is for the module to serve as a factory that MUST return\ninstance of \nApplication\n, since application is a middleware it does not\nintroduce a very specific behaviour, except maybe for having a separate\nmiddleware delegate defined and a separate router for the module itself.\n\n\nInternally the \nModuleDelegateFactory\n is building a router with every\ninstance \nApplication\n assigned it's own prefix inside a \nmodule\n key.\n\n\nConfiguration\n\n\nThe minimal configuration to the container is:\n\n\nreturn [\n    // .. other configuration\n    'middleware' =\n [\n        'modules'\n    ],\n    'modules' =\n [\n        '/path/prefix' =\n MyApp\\API\\Module::class\n    ]\n]\n\n\n\n\nAn example module class:\n\n\nnamespace MyApp\\API;\n\nuse Interop\\Container\\ContainerInterface;\nuse Onion\\Framework\\Application\\Application;\nuse Onion\\Framework\\Application\\Interfaces\\ModuleInterface;\n\nclass Module implements ModuleInterface\n{\n    // Optional, but makes things clearer\n    private function getConfigurations(): array\n    {\n        return [\n            'routes' =\n [\n                [\n                    'pattern' =\n '/api/users',\n                    'middleware' =\n [\n                        UsersApiController::class\n                    ]\n                ]\n            ]\n        ];\n    }\n\n    public function build(ContainerInterface $container): Application\n    {\n        return new Application\n            // Retrieve everything from a contextual container\n            $this-\ngetOwnContainer()-\nget(\\Interop\\Middleware\\DelegateInterface),\n            $container-\nget(EmitterInterface::class)\n        );\n    }\n}\n\n\n\n\nIt is recommended for a module class to fetch the \nEmitterInterface\n\nfrom the main container, instead of defining it's own since it will\navoid issues with custom emitter implementations if applicable. Also\nnote that the route must have the prefix defined by default in order to\navoid this duplication (if that is your thing, but do keep in mind that\nthe intent behind this kind of modules is that a module can and should\nbe able to function as it's own application and not only as a module of\nanother). Once the initial testing has been performed a CLI application\nwill be developed allowing for the generation of module classes from\nexisting applications, which will empower use-cases such as minimal blog\nto be embedded inside another application at a prefix; as well as\ninstall/uninstall steps, but that is TBD as of now so don't rely\ncompletely on that, but do keep in mind that the reasoning behind the\nmodules is here to stay.\n\n\nRecommendations\n\n\nMajority of the following points are intended to serve only as\nguide lines, and developers are free to ignore them, but complying\nwill ensure consistency between module structure and workflow, hence\nimproving experience\n\n\n\n\n\n\nA module is a component of an application or website that provides visitor\n access to specific part of the website, a module should not only provide\n libraries and/or frameworks (for that part please stick with composer, see\n \ncomposer documentation for information on how to use VCS for package distribution\n).\n\n\n\n\n\n\nA module should provide contact information to allow users to report issues\n make/discuss feature requests and/or disclose security vulnerabilities.\n\n\n\n\n\n\nAnother highly recommended thing to do is follow the PHP standards (PSR) to\n ensure compatibility with other libraries/modules/frameworks, that the\n user might be using within their application, out of the box.\n\n\n\n\n\n\nFollowing the HTTP standards is also a good thing to do, since that will\n increase the flexibility of user implementations in a magnitude. Example:\n if you provide \nLast-Modified\n header and check for \nIf-Modified-Since\n\n the application may become more performant, since no data should be\n transfered.\n\n\n\n\n\n\nAs a developer you should try to keep the dependencies for your module\n as minimal as possible so users do not get bloated with dependencies,\n also as a added benefit you lower the risk of your module breaking, because\n of external changes.\n\n\n\n\n\n\nA module, should not provide/enforce specific view components, since it\n may break application/website functionality/appearance, rather a API backend\n should be previded with information/tutorials/examples on how to communicate\n with said backend in a consistent way. *Design your modules for front ends\n built using modern frameworks like, ReactJS and Angular2 or other similar ones.\n\n\n\n\n\n\nA module should be kept as small and self-contained as possible. For example\n if a module is intended to provide blogging functionality it should (where applicable)\n be split in separate compoenets for \nposts\n, \ncomments\n, \nediting\n. That way users\n would have the opportunity to mix and match compoents that are compatible or directly\n write a custom one to fit their needs or bridge gaps between different modules.\n\n\n\n\n\n\nA module may communicate with existing services, but it is recommended to provide\n information with which services/3rd parties information is exchanged and for what\n purposes.\n\n\n\n\n\n\nA module should not intend to modify files inside or outside of itself, when such\n configuration is required it should provide detailed information what, where and why\n should be changed for the user to configure (or optionally a script can be provided,\n but not automatically executed)\n\n\n\n\n\n\nOptionally your module may provide a UI, but it should be implemented in such a way\n that it's styling should be easily changeable since, different people have different\n tastes.", 
            "title": "Modules"
        }, 
        {
            "location": "/modules/#introduction", 
            "text": "Modules are not a new concept in the development world, nor they re new\nto the PHP frameworks/applications. The implementation used here is not\ntoo different from what has already been implemented in other frameworks\nbut the intent is clear and is aimed at enforcing the separation of\napplications in logical parts, rather than having module provide\nhelper functionality (although they can also be used in that way, but\nmight fee less intuitive)", 
            "title": "Introduction"
        }, 
        {
            "location": "/modules/#setup", 
            "text": "A module must be as self-contained as possible. It is up to the module\ndeveloper to determine what configuration is comming from where, but\nmandatory (such as internal dependency mapping) should be defined and\nmight even be appropriate to have it hardcoded, but optional things,\nsuch as database connection settings, etc. should be retrieved from the\nmain application container via an acceptable method explained inside\nmodule's  readme  on  installation  files.  A module should have it's logic as self-contained as possible, except\nfor configurations, since that will change from application to\napplication.  The only requirement in order to ensure consistency (as of now it is not\nenforced) is for the module to serve as a factory that MUST return\ninstance of  Application , since application is a middleware it does not\nintroduce a very specific behaviour, except maybe for having a separate\nmiddleware delegate defined and a separate router for the module itself.  Internally the  ModuleDelegateFactory  is building a router with every\ninstance  Application  assigned it's own prefix inside a  module  key.", 
            "title": "Setup"
        }, 
        {
            "location": "/modules/#configuration", 
            "text": "The minimal configuration to the container is:  return [\n    // .. other configuration\n    'middleware' =  [\n        'modules'\n    ],\n    'modules' =  [\n        '/path/prefix' =  MyApp\\API\\Module::class\n    ]\n]  An example module class:  namespace MyApp\\API;\n\nuse Interop\\Container\\ContainerInterface;\nuse Onion\\Framework\\Application\\Application;\nuse Onion\\Framework\\Application\\Interfaces\\ModuleInterface;\n\nclass Module implements ModuleInterface\n{\n    // Optional, but makes things clearer\n    private function getConfigurations(): array\n    {\n        return [\n            'routes' =  [\n                [\n                    'pattern' =  '/api/users',\n                    'middleware' =  [\n                        UsersApiController::class\n                    ]\n                ]\n            ]\n        ];\n    }\n\n    public function build(ContainerInterface $container): Application\n    {\n        return new Application\n            // Retrieve everything from a contextual container\n            $this- getOwnContainer()- get(\\Interop\\Middleware\\DelegateInterface),\n            $container- get(EmitterInterface::class)\n        );\n    }\n}  It is recommended for a module class to fetch the  EmitterInterface \nfrom the main container, instead of defining it's own since it will\navoid issues with custom emitter implementations if applicable. Also\nnote that the route must have the prefix defined by default in order to\navoid this duplication (if that is your thing, but do keep in mind that\nthe intent behind this kind of modules is that a module can and should\nbe able to function as it's own application and not only as a module of\nanother). Once the initial testing has been performed a CLI application\nwill be developed allowing for the generation of module classes from\nexisting applications, which will empower use-cases such as minimal blog\nto be embedded inside another application at a prefix; as well as\ninstall/uninstall steps, but that is TBD as of now so don't rely\ncompletely on that, but do keep in mind that the reasoning behind the\nmodules is here to stay.", 
            "title": "Configuration"
        }, 
        {
            "location": "/modules/#recommendations", 
            "text": "Majority of the following points are intended to serve only as\nguide lines, and developers are free to ignore them, but complying\nwill ensure consistency between module structure and workflow, hence\nimproving experience    A module is a component of an application or website that provides visitor\n access to specific part of the website, a module should not only provide\n libraries and/or frameworks (for that part please stick with composer, see\n  composer documentation for information on how to use VCS for package distribution ).    A module should provide contact information to allow users to report issues\n make/discuss feature requests and/or disclose security vulnerabilities.    Another highly recommended thing to do is follow the PHP standards (PSR) to\n ensure compatibility with other libraries/modules/frameworks, that the\n user might be using within their application, out of the box.    Following the HTTP standards is also a good thing to do, since that will\n increase the flexibility of user implementations in a magnitude. Example:\n if you provide  Last-Modified  header and check for  If-Modified-Since \n the application may become more performant, since no data should be\n transfered.    As a developer you should try to keep the dependencies for your module\n as minimal as possible so users do not get bloated with dependencies,\n also as a added benefit you lower the risk of your module breaking, because\n of external changes.    A module, should not provide/enforce specific view components, since it\n may break application/website functionality/appearance, rather a API backend\n should be previded with information/tutorials/examples on how to communicate\n with said backend in a consistent way. *Design your modules for front ends\n built using modern frameworks like, ReactJS and Angular2 or other similar ones.    A module should be kept as small and self-contained as possible. For example\n if a module is intended to provide blogging functionality it should (where applicable)\n be split in separate compoenets for  posts ,  comments ,  editing . That way users\n would have the opportunity to mix and match compoents that are compatible or directly\n write a custom one to fit their needs or bridge gaps between different modules.    A module may communicate with existing services, but it is recommended to provide\n information with which services/3rd parties information is exchanged and for what\n purposes.    A module should not intend to modify files inside or outside of itself, when such\n configuration is required it should provide detailed information what, where and why\n should be changed for the user to configure (or optionally a script can be provided,\n but not automatically executed)    Optionally your module may provide a UI, but it should be implemented in such a way\n that it's styling should be easily changeable since, different people have different\n tastes.", 
            "title": "Recommendations"
        }
    ]
}